/*! angular-wakanda - v0.4.2 - 2014-12-22 */
(function(exports, global) {
    global["true"] = exports;
    var Class;
    (function() {
        var initializing = false, fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/;
        Class = function() {};
        Class.extend = function(prop) {
            var _super = this.prototype;
            initializing = true;
            var prototype = new this();
            initializing = false;
            for (var name in prop) prototype[name] = "function" == typeof prop[name] && "function" == typeof _super[name] && fnTest.test(prop[name]) ? function(name, fn) {
                return function() {
                    var tmp = this._super;
                    this._super = _super[name];
                    var ret = fn.apply(this, arguments);
                    this._super = tmp;
                    return ret;
                };
            }(name, prop[name]) : prop[name];
            function Class() {
                if (!initializing && this.init) this.init.apply(this, arguments);
            }
            Class.prototype = prototype;
            Class.prototype.constructor = Class;
            Class.extend = arguments.callee;
            return Class;
        };
    })();
    var WAF = {
        core: {},
        config: {}
    };
    function ISOToDate(string) {
        var dd = new Date();
        dd.setISO(string);
        return dd;
    }
    function stringToSimpleDate(string) {
        if (null == string || "" == string) return null;
        var arr = string.split("!");
        if (arr.length < 3) return null;
        return new Date(Number(arr[2]), Number(arr[1]) - 1, Number(arr[0]));
    }
    Date.prototype.toJSON = function(key) {
        return this.toISO() + "," + this.toSimpleDateString();
    };
    Date.prototype.toSimpleDateString = function() {
        return "" + this.getDate() + "!" + (this.getMonth() + 1) + "!" + (this.getYear() + 1900);
    };
    Date.prototype.setISO = function(string) {
        var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})" + "(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(.([0-9]+))?)?" + "(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?";
        var d = string.match(new RegExp(regexp));
        var offset = 0;
        var date = new Date(d[1], 0, 1);
        if (d[3]) date.setMonth(d[3] - 1);
        if (d[5]) date.setDate(d[5]);
        if (d[7]) date.setHours(d[7]);
        if (d[8]) date.setMinutes(d[8]);
        if (d[10]) date.setSeconds(d[10]);
        if (d[12]) date.setMilliseconds(1e3 * Number("0." + d[12]));
        if (d[14]) {
            offset = 60 * Number(d[16]) + Number(d[17]);
            offset *= "-" == d[15] ? 1 : -1;
        }
        offset -= date.getTimezoneOffset();
        time = Number(date) + 60 * offset * 1e3;
        this.setTime(Number(time));
    };
    Date.prototype.toISO = function(format, offset) {
        if (!format) var format = 6;
        if (!offset) {
            var offset = "Z";
            var date = this;
        } else {
            var d = offset.match(/([-+])([0-9]{2}):([0-9]{2})/);
            var offsetnum = 60 * Number(d[2]) + Number(d[3]);
            offsetnum *= "-" == d[1] ? -1 : 1;
            var date = new Date(Number(Number(this) + 6e4 * offsetnum));
        }
        var zeropad = function(num) {
            return (num < 10 ? "0" : "") + num;
        };
        var str = "";
        str += date.getUTCFullYear();
        if (format > 1) str += "-" + zeropad(date.getUTCMonth() + 1);
        if (format > 2) str += "-" + zeropad(date.getUTCDate());
        if (format > 3) str += "T" + zeropad(date.getUTCHours()) + ":" + zeropad(date.getUTCMinutes());
        if (format > 5) {
            var secs = Number(date.getUTCSeconds() + "." + (date.getUTCMilliseconds() < 100 ? "0" : "") + zeropad(date.getUTCMilliseconds()));
            str += ":" + zeropad(secs);
        } else if (format > 4) str += ":" + zeropad(date.getUTCSeconds());
        if (format > 3) str += offset;
        return str;
    };
    Date.prototype.isValid = function() {
        return !isNaN(this.getTime());
    };
    WAF.core.restConnect = {};
    WAF.core.restConnect.httpMethods = {
        _post: "POST",
        _get: "GET",
        _put: "PUT",
        _delete: "DELETE"
    };
    WAF.core.restConnect.restActions = {
        _retrieve: "retrieve",
        _create: "create",
        _update: "update",
        _delete: "delete"
    };
    WAF.core.restConnect.queryOptions = {
        _expand: "$expand",
        _orderby: "$orderby",
        _skip: "$skip",
        _top: "$top",
        _filter: "$filter"
    };
    WAF.core.restConnect.filterOperators = {
        _equal: "eq",
        _notequal: "neq",
        _greaterthan: "gt",
        _greaterthanorequal: "gteq",
        _lessthan: "lt",
        _lessthanorequal: "lteq",
        _logicaland: "and",
        _logicalor: "or",
        _logicalnot: "not"
    };
    WAF.core.restConnect.filterArithmeticOperators = {
        _add: "add",
        _sub: "sub",
        _mul: "mul",
        _div: "div",
        _mod: "mod"
    };
    WAF.core.restConnect.defaultService = "rest";
    WAF.core.restConnect.standardErrors = {
        _hostnamemissing: {
            key: "1",
            string: "The hostname is missing."
        },
        _servicemissing: {
            key: "2",
            string: "The service is missing."
        },
        _httpmethodundefined: {
            key: "3",
            string: "The HTTP method is undefined."
        },
        _wronghttpmethod: {
            key: "4",
            string: "The HTTP method get doesn't support POST data."
        }
    };
    WAF.core.restConnect.getXMLHttpRequest = function() {
        var http_request = false;
        if (window.XMLHttpRequest) http_request = new XMLHttpRequest(); else if (window.ActiveXObject) ;
        return http_request;
    };
    WAF.core.restConnect.restRequest = function(connectionMode) {
        this.connectionMode = connectionMode;
        this.fullURL = null;
        this.httpMethod = WAF.core.restConnect.httpMethods._get;
        this.hostname = "";
        this.app = WAF.config.pattern;
        this.service = WAF.core.restConnect.defaultService;
        this.resource = "";
        this.attributesRequested = void 0;
        this.keys = [];
        this.expand = [];
        this.orderby = [];
        this.skip = null;
        this.top = null;
        this.filter = null;
        this.method = null;
        this.metadata = null;
        this.handler = null;
        this.postdata = null;
        this.queryPlan = null;
        this.progressInfo = null;
        this.distinct = false;
        this.refreshOnly = false;
        this.error = {
            key: 0,
            string: ""
        };
        this.orderByArgsToString = function() {
            var retString = "";
            if ("string" === typeof this.orderby) return this.orderby;
            if (this.orderby.length > 0) retString = this.orderby[0];
            for (var i = 1; i < this.orderby.length; i++) retString += "," + this.orderby[i];
            return retString;
        };
        this.go = function(options) {
            var handler = this.handler;
            var url = "/";
            if (null != this.app) url += this.app + "/";
            if ("" !== this.service) url += this.service + "/"; else {
                this.error = WAF.core.restConnect.standardErrors._servicemissing;
                return false;
            }
            if ("" !== this.resource) {
                url += this.resource + "/";
                if (this.keys.length > 0) {
                    url += "(";
                    for (var i = 0; i < this.keys.length; i++) {
                        url += this.keys[i];
                        if (i < this.keys.length - 1) url += ",";
                    }
                    url += ")";
                }
            }
            var deja$ = false;
            if (this.dataURI) {
                url = this.dataURI;
                deja$ = url.indexOf("?") !== -1;
                if (!deja$) url += "/";
            }
            var needToAddQuaestionMark = !deja$;
            if (void 0 != this.attributesRequested) {
                if (this.attributesRequested.length > 0) {
                    url += this.attributesRequested[0];
                    for (var i = 1; i < this.attributesRequested.length; i++) url += "," + this.attributesRequested[i];
                }
                url += "/";
            }
            var queryString = "";
            if (this.skip) {
                queryString += (!deja$ ? "$skip=" : "&$skip=") + this.skip;
                deja$ = true;
            }
            if (this.top) {
                queryString += (!deja$ ? "$top=" : "&$top=") + this.top;
                deja$ = true;
            }
            if (this.filter) {
                queryString += (!deja$ ? "$filter=" : "&$filter=") + encodeURIComponent("'" + this.filter + "'");
                deja$ = true;
            }
            if (this.params) {
                queryString += (!deja$ ? "$params=" : "&$params=") + encodeURIComponent("'" + JSON.stringify(this.params) + "'");
                deja$ = true;
            }
            if (this.method) {
                queryString += (!deja$ ? "$method=" : "&$method=") + this.method;
                deja$ = true;
            }
            if (this.asArray) {
                queryString += (!deja$ ? "$asArray=" : "&$asArray=") + "true";
                deja$ = true;
            }
            if (this.metadata) {
                queryString += (!deja$ ? "$metadata=" : "&$metadata=") + this.metadata;
                deja$ = true;
            }
            if (null != this.mustlock) {
                queryString += (!deja$ ? "$lock=" : "&$lock=") + this.mustlock;
                deja$ = true;
            }
            if (this.distinct) {
                queryString += (!deja$ ? "$distinct=" : "&$distinct=") + this.distinct;
                deja$ = true;
            }
            if (null != this.findKey) {
                queryString += (!deja$ ? "$findKey=" : "&$findKey=") + encodeURIComponent("" + this.findKey);
                deja$ = true;
            }
            if (null != this.reselect) {
                queryString += (!deja$ ? "$reselect=" : "&$reselect=") + encodeURIComponent("" + this.reselect);
                deja$ = true;
            }
            if (this.queryPlan) {
                queryString += !deja$ ? "$queryplan=true&querypath=true" : "&$queryplan=true&querypath=true";
                deja$ = true;
            }
            if (this.progressInfo) {
                queryString += (!deja$ ? "$progressinfo=" : "&$progressinfo=") + encodeURIComponent(this.progressInfo);
                deja$ = true;
            }
            if (this.timeout) {
                queryString += (!deja$ ? "$timeout=" : "&$timeout=") + this.timeout;
                deja$ = true;
            }
            if (this.savedQueryString) {
                queryString += (!deja$ ? "$savedfilter=" : "&$savedfilter=") + encodeURIComponent("'" + this.savedQueryString + "'");
                deja$ = true;
            }
            if (this.savedOrderby) {
                queryString += (!deja$ ? "$savedorderby=" : "&$savedorderby=") + this.savedOrderby;
                deja$ = true;
            }
            if (this.refreshOnly) {
                queryString += (!deja$ ? "$refresh=" : "&$refresh=") + this.refreshOnly;
                deja$ = true;
            }
            if (this.atOnce) {
                queryString += (!deja$ ? "$atOnce=" : "&$atOnce=") + this.atOnce;
                deja$ = true;
            }
            if (this.retainPositions) {
                queryString += (!deja$ ? "$retainPositions=" : "&$retainPositions=") + this.retainPositions;
                deja$ = true;
            }
            if (null != this.removeAtPos) {
                queryString += (!deja$ ? "$removeFromSet=" : "&$removeFromSet=") + this.removeAtPos;
                deja$ = true;
            }
            if (null != this.removeReferenceOnly) {
                queryString += (!deja$ ? "$removeRefOnly=" : "&$removeRefOnly=") + this.removeReferenceOnly;
                deja$ = true;
            }
            if (null != this.filterAttributes) {
                queryString += (!deja$ ? "$attributes=" : "&$attributes=") + encodeURIComponent(this.filterAttributes);
                deja$ = true;
            }
            if (null != this.addToSet) {
                queryString += (!deja$ ? "$addToSet=" : "&$addToSet=") + encodeURIComponent("'" + JSON.stringify(this.addToSet) + "'");
                deja$ = true;
            }
            if (null != this.fromSelection) {
                queryString += (!deja$ ? "$fromSel=" : "&$fromSel=") + encodeURIComponent("'" + JSON.stringify(this.fromSelection) + "'");
                deja$ = true;
            }
            if (null != this.keepSelection) {
                queryString += (!deja$ ? "$keepSel=" : "&$keepSel=") + encodeURIComponent("'" + JSON.stringify(this.keepSelection) + "'");
                deja$ = true;
            }
            if (this.orderby) if (this.orderby.length) {
                if (!deja$) queryString += "$orderby=" + this.orderByArgsToString(); else queryString += "&$orderby=" + this.orderByArgsToString();
                deja$ = true;
            }
            if (null != this.subOrderby) {
                queryString += (!deja$ ? "$subOrderby=" : "&$subOrderby=") + encodeURIComponent(this.subOrderby);
                deja$ = true;
            }
            if (void 0 != this.attributesExpanded) if (this.attributesExpanded.length > 0) {
                var expandString = "";
                if (!deja$) queryString += "$expand="; else queryString += "&$expand=";
                deja$ = true;
                for (var i = 0; i < this.attributesExpanded.length; i++) if ("" === expandString) expandString += this.attributesExpanded[i]; else expandString += "," + this.attributesExpanded[i];
                queryString += expandString;
            }
            if (null != this.autoExpand && "" != this.autoExpand) {
                if (!deja$) queryString += "$expand="; else queryString += "&$expand=";
                deja$ = true;
                queryString += this.autoExpand;
            }
            if (null != this.autoSubExpand && "" != this.autoSubExpand) {
                if (!deja$) queryString += "$subExpand="; else queryString += "&$subExpand=";
                deja$ = true;
                queryString += this.autoSubExpand;
            }
            if ("" !== queryString) {
                if (needToAddQuaestionMark) url += "?";
                url += queryString;
            }
            var command = "";
            if ("" !== this.httpMethod) command = this.httpMethod; else this.error = WAF.core.restConnect.httpMethods._get;
            if (this.postdata && command == WAF.core.restConnect.httpMethods._get) {
                this.error = WAF.core.restConnect.standardErrors._wronghttpmethod;
                return false;
            }
            this.http_request = WAF.core.restConnect.getXMLHttpRequest();
            if (!this.http_request) return;
            this.http_request.parent = this;
            if (options && options.generateRESTRequestOnly) return url; else {
                if (null != handler) this.http_request.onreadystatechange = function() {
                    handler(this.parent);
                };
                try {
                    if (this.fullURL) url = this.fullURL;
                    this.http_request.open(command, url, this.connectionMode);
                    if (this.postdata) this.http_request.setRequestHeader("Content-Type", "application/json");
                    this.http_request.setRequestHeader("If-Modified-Since", "Thu, 1 Jan 1970 00:00:00 GMT");
                    this.http_request.setRequestHeader("Cache-Control", "no-cache");
                    this.http_request.send(this.postdata);
                    if (!this.connectionMode) handler(this.http_request);
                    return true;
                } catch (e) {
                    return true;
                }
            }
            return false;
        };
    };
    WAF.callHandler = function(withError, errorInfo, event, options, userData) {
        var result = null;
        event.userData = userData;
        if (withError) {
            var onError = options.onError;
            event.error = errorInfo;
            if (null != onError) result = onError(event);
        } else {
            var onsuccess = options.onSuccess;
            if (null != onsuccess) result = onsuccess(event);
        }
        return result;
    };
    WAF.getRequestResult = function(request) {
        var response = request.http_request.responseText;
        var result;
        if (null == response) result = {
            __ERROR: [ {
                errCode: -1
            } ]
        }; else try {
            result = JSON.parse(response);
        } catch (e) {
            result = {
                __ERROR: [ e ]
            };
        }
        return result;
    };
    WAF.tools = {};
    WAF.tools.optionMatchers = [ "onSuccess", "onError", "atTheEnd", "sync", "autoExpand", "autoSubExpand", "catalog", "queryString", "skip", "top", "position", "orderby", "orderBy", "params", "queryPlan", "queryPath", "pageSize", "filterSet", "progressInfo", "progressBar", "delay", "delayInfo", "method", "first", "limit", "userData", "addToSet", "atOnce", "refreshOnly", "keepOldCollectionOnError", "isMethodResult", "prefetchedData", "callWithGet", "generateRESTRequestOnly", "forceReload", "doNotAlterElemPos", "overrideStamp", "queryParams", "createEmptyCollection", "forceCollectionRefresh", "refreshCollectionFrom", "removeReferenceOnly", "timeout", "doNotDispatch", "destinationDataSource", "filterAttributes", "subOrderby", "filterQuery", "withinCollection", "keepOrderBy", "retainPositions", "fromInitialQuery", "reselect" ];
    WAF.tools.isOptionParam = function(param) {
        var result = false;
        if (null != param) if ("object" === typeof param) {
            var op = WAF.tools.optionMatchers;
            var len = op.length;
            for (var i = 0; i < len && !result; ++i) {
                var s = op[i];
                if (s in param) {
                    result = true;
                    break;
                }
            }
        }
        return result;
    };
    WAF.tools.handleArgs = function(args, startingFrom, handleOptions) {
        var alreadyOptions = false;
        handleOptions = handleOptions || {};
        startingFrom = startingFrom || 0;
        var noUserData = handleOptions.noUserData || false;
        var with3funcs = handleOptions.with3funcs || false;
        var queryParams = handleOptions.queryParams || false;
        var res = {
            options: {},
            userData: null
        };
        var p;
        var nbparam = args.length;
        var nextparam = startingFrom;
        if (nextparam < nbparam) {
            p = args[nextparam];
            if ("function" === typeof p) {
                res.options.onSuccess = p;
                ++nextparam;
                if (nextparam < nbparam) {
                    p = args[nextparam];
                    if ("function" === typeof p) {
                        res.options.onError = p;
                        ++nextparam;
                        if (nextparam < nbparam) {
                            p = args[nextparam];
                            if (with3funcs && "function" === typeof p) {
                                res.options.atTheEnd = p;
                                ++nextparam;
                            }
                        }
                    }
                }
                if (null == res.options.onError) res.options.onError = res.options.onSuccess;
            }
        }
        var params = null;
        if (queryParams) params = [];
        do if (nextparam < nbparam) {
            p = args[nextparam];
            if (!alreadyOptions && WAF.tools.isOptionParam(p)) {
                alreadyOptions = true;
                ++nextparam;
                var oldoptions = res.options;
                res.options = p;
                if (null != oldoptions.onSuccess) res.options.onSuccess = oldoptions.onSuccess;
                if (null != oldoptions.onError) res.options.onError = oldoptions.onError;
                if (null != oldoptions.atTheEnd) res.options.atTheEnd = oldoptions.atTheEnd;
                if (!queryParams) if (nextparam < nbparam && !noUserData) {
                    res.userData = args[nextparam];
                    ++nextparam;
                }
            } else if (queryParams) if ("object" === typeof p && !(p instanceof Date) && !(p instanceof Array)) {
                res.userData = p;
                ++nextparam;
            } else {
                params.push(p);
                ++nextparam;
            }
        } while (queryParams && nextparam < nbparam);
        if (null != res.options.userData && null == res.userData) res.userData = res.options.userData;
        if (queryParams) res.options.params = res.options.params || params;
        res.nextParam = nextparam;
        return res;
    };
    WAF.EntityCache = function(options) {
        options = options || {};
        var cache = this;
        this.maxEntities = options.maxEntities || 300;
        this.timeOut = options.timeOut || 5 * 60 * 1e3;
        this.entitiesByKey = {};
        this.nbEntries = 0;
        this.curStamp = 0;
    };
    WAF.EntityCache.prototype.getNextStamp = function() {
        var cache = this;
        cache.curStamp++;
        return cache.curStamp;
    };
    WAF.EntityCache.prototype.clear = function(nbToClear) {
        var cache = this;
        if (null == nbToClear || nbToClear >= cache.nbEntries) {
            cache.entitiesByKey = {};
            cache.nbEntries = 0;
        } else {
            var all = [];
            var map = cache.entitiesByKey;
            for (var e in map) all.push(map[e]);
            all.sort(function(e1, e2) {
                return e1.timeStamp > e2.timeStamp ? 1 : -1;
            });
            var nbelem = nbToClear;
            if (nbelem > all.length) nbelem = all.length;
            var nbEntries = cache.nbEntries;
            for (var i = 0; i < nbelem; i++) {
                var entry = all[i];
                delete map[entry.key];
                --nbEntries;
            }
            cache.nbEntries = nbEntries;
            delete all;
        }
    };
    WAF.EntityCache.prototype.makeRoomFor = function(nbEntities) {
        var cache = this;
        if (cache.maxEntities < 2 * nbEntities) cache.maxEntities = 2 * nbEntities;
        var remain = cache.maxEntities - cache.nbEntries;
        if (remain < nbEntities) cache.clear(nbEntities - remain);
    };
    WAF.EntityCache.prototype.setEntry = function(key, rawEntity, timeStamp, options) {
        function mergeRawEntity(newRawEntity, oldRawEntity) {
            for (e in oldRawEntity) {
                var newval = newRawEntity[e];
                if (null == newval) newRawEntity[e] = oldRawEntity[e]; else if (null != newval.__deferred) newRawEntity[e] = oldRawEntity[e];
            }
            return newRawEntity;
        }
        var cache = this;
        var map = cache.entitiesByKey;
        var elem = map[key];
        if (null == elem) {
            if (cache.nbEntries >= cache.maxEntities) cache.clear(Math.round(cache.nbEntries / 3));
            cache.nbEntries++;
        } else {
            var oldstamp = -1;
            var newstamp = null;
            if (null != rawEntity) newstamp = rawEntity.__STAMP;
            if (null != elem.rawEntity) oldstamp = elem.rawEntity.__STAMP;
            if (oldstamp === newstamp) rawEntity = mergeRawEntity(rawEntity, elem.rawEntity);
        }
        var newStamp = cache.getNextStamp();
        map[key] = {
            key: key,
            timeStamp: timeStamp,
            rawEntity: rawEntity,
            stamp: newStamp
        };
        return newStamp;
    };
    WAF.EntityCache.prototype.getCacheInfo = function(key) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        return elem;
    };
    WAF.EntityCache.prototype.replaceCachedEntity = function(key, rawEntity) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        if (null != elem) {
            elem.timeStamp = new Date();
            elem.rawEntity = rawEntity;
            elem.stamp = cache.getNextStamp();
        }
    };
    WAF.EntityCache.prototype.removeCachedEntity = function(key) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        if (null != elem) delete cache.entitiesByKey[key];
    };
    WAF.EntityCache.prototype.setSize = function(nbEntries) {
        if (null == nbEntries || nbEntries < 300) nbEntries = 300;
        this.maxEntities = nbEntries;
    };
    WAF.EntityRefCache = function(options) {
        options = options || {};
        var cache = this;
        this.maxEntities = options.maxEntities || 300;
        this.timeOut = options.timeOut || 5 * 60 * 1e3;
        this.entitiesByKey = {};
        this.nbEntries = 0;
        this.curStamp = 0;
    };
    WAF.EntityRefCache.prototype.clear = function(nbToClear) {
        var cache = this;
        if (null == nbToClear || nbToClear >= cache.nbEntries) {
            cache.entitiesByKey = {};
            cache.nbEntries = 0;
        } else {
            var all = [];
            var map = cache.entitiesByKey;
            for (var e in map) all.push(map[e]);
            all.sort(function(e1, e2) {
                return e1.timeStamp > e2.timeStamp ? 1 : -1;
            });
            var nbelem = nbToClear;
            if (nbelem > all.length) nbelem = all.length;
            var nbEntries = cache.nbEntries;
            for (var i = 0; i < nbelem; i++) {
                var entry = all[i];
                delete map[entry.key];
                --nbEntries;
            }
            cache.nbEntries = nbEntries;
            delete all;
        }
    };
    WAF.EntityRefCache.prototype.makeRoomFor = function(nbEntities) {
        var cache = this;
        if (cache.maxEntities < 2 * nbEntities) cache.maxEntities = 2 * nbEntities;
        var remain = cache.maxEntities - cache.nbEntries;
        if (remain < nbEntities) cache.clear(nbEntities - remain);
    };
    WAF.EntityRefCache.prototype.setEntry = function(entity) {
        var key = entity.getKey();
        if (null != key) {
            var cache = this;
            var map = cache.entitiesByKey;
            var elem = map[key];
            var timeStamp = new Date();
            if (null == elem) {
                if (cache.nbEntries >= cache.maxEntities) cache.clear(Math.round(cache.nbEntries / 3));
                cache.nbEntries++;
                map[key] = {
                    key: key,
                    timeStamp: timeStamp,
                    entity: entity
                };
            } else {
                if (elem.entity !== entity) cache.mergeEntity(elem.entity, entity);
                elem.timeStamp = timeStamp;
            }
        }
    };
    WAF.EntityRefCache.prototype.mergeEntity = function(entity, otherentity) {
        entity._private.stamp = otherentity._private.stamp;
        entity._private.touched = false;
        var values = entity._private.values;
        var othervalues = otherentity._private.values;
        var attsByName = entity._private.dataClass._private.attributesByName;
        for (var e in attsByName) {
            var attval = othervalues[e] || null;
            if (null == attval) {
                delete values[e];
                delete entity[e];
            } else {
                values[e] = attval;
                entity[e] = attval;
            }
        }
    };
    WAF.EntityRefCache.prototype.getCacheInfo = function(key) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        return elem;
    };
    WAF.EntityRefCache.prototype.removeCachedEntity = function(key) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        if (null != elem) delete cache.entitiesByKey[key];
    };
    WAF.EntityRefCache.prototype.setSize = function(nbEntries) {
        if (null == nbEntries || nbEntries < 300) nbEntries = 300;
        this.maxEntities = nbEntries;
    };
    WAF.DataStore = function(options, userData) {
        options = options || {};
        userData = userData;
        var dataStore = this;
        this._private = {
            owner: this,
            dataClasses: {},
            dataClassesByCollectionName: {},
            ready: false,
            cacheRef: options.cacheRef || false,
            getCatalog: WAF.DataStore.getCatalog
        };
        dataStore._private.getCatalog(options, userData);
    };
    WAF.DataStore.prototype.getDataClass = function(name) {
        var priv = this._private;
        var dataClass = priv.dataClasses[name];
        if (null == dataClass) dataClass = priv.dataClassesByCollectionName[name];
        return dataClass;
    };
    WAF.DataStore.prototype.getDataClasses = function() {
        var priv = this._private;
        return priv.dataClasses;
    };
    WAF.DataStore.prototype.mustCacheRef = function() {
        return this._private.cacheRef;
    };
    WAF.DataStore.prototype.addToCatalog = function(dataClassesList, options, userData) {
        userData = userData || null;
        options = options || {};
        var priv = this._private;
        options.catalog = dataClassesList;
        options.mergeCatalog = true;
        priv.getCatalog(options, userData);
    };
    WAF.DataStore.resolveRelatedAttribute = function() {
        if (!this.resolved) {
            var dataStore = this.owner.getDataStore();
            this.relatedClass = dataStore.getDataClass(this.type);
            if (null != this.relatedClass) this.resolved = true;
        }
    };
    WAF.DataStore.getRelatedClassAttribute = function() {
        this.resolve();
        return this.relatedClass;
    };
    WAF.DataStore.handleFuncResult = function(request, methodref, dataClass) {
        var fullResult = WAF.getRequestResult(request);
        if (null == fullResult.__ERROR) {
            if (null != fullResult.__entityModel) dataClass = dataClass.getDataStore().getDataClass(fullResult.__entityModel);
            if (null != fullResult.__KEY || null != fullResult.__STAMP) {
                var entity = new WAF.Entity(dataClass, fullResult, {
                    getRefFromCache: true
                });
                fullResult = {
                    result: entity
                };
            } else if (null != fullResult.__ENTITIES) {
                var entityCollection = new WAF.EntityCollection(dataClass, null, {
                    prefetchedData: fullResult,
                    isMethodResult: true
                });
                fullResult = {
                    result: entityCollection
                };
            }
        }
        return fullResult;
    };
    WAF.DataStore.funcCaller = function(methodref, from, params, options) {
        var result = null;
        options = options || {};
        var oktogo = true;
        var sync = options.sync || false;
        var callWithGet = methodref.callWithGet || options.callWithGet || false;
        var generateRESTRequestOnly = options.generateRESTRequestOnly || false;
        var request = new WAF.core.restConnect.restRequest(!sync);
        if (callWithGet) request.httpMethod = WAF.core.restConnect.httpMethods._get; else request.httpMethod = WAF.core.restConnect.httpMethods._post;
        var entity = null;
        var dataClass = null;
        var entityCollection = null;
        var jsonargs = JSON.stringify(params);
        if (callWithGet) request.params = params; else request.postdata = jsonargs;
        if ("entity" == methodref.applyTo) {
            entity = from;
            dataClass = entity.getDataClass();
            request.attributesRequested = [ methodref.name ];
            request.resource = dataClass.getName() + "(";
            var key = entity.getKey();
            if (null != key) request.resource += key;
            request.resource += ")";
        } else if ("entityCollection" == methodref.applyTo) {
            entityCollection = from;
            dataClass = entityCollection.getDataClass();
            if (null != entityCollection._private.dataURI) request.dataURI = entityCollection._private.dataURI + "/" + methodref.name; else {
                request.attributesRequested = [ methodref.name ];
                request.resource = dataClass.getName();
                request.filter = options.queryString;
            }
            request.savedQueryString = entityCollection._private.savedQuery;
            request.savedOrderby = entityCollection._private.savedOrderby;
            entityCollection._private.updateOptions(options);
        } else if ("general" == methodref.applyTo) {
            request.resource = methodref.nameSpace;
            request.attributesRequested = [ methodref.name ];
        } else {
            dataClass = from;
            request.attributesRequested = [ methodref.name ];
            request.resource = dataClass.getName();
        }
        var pageSize = options.pageSize || 40;
        request.top = pageSize;
        request.method = "entityset";
        request.timeout = 300;
        request.addToSet = options.addToSet;
        if (null != options.autoExpand) request.autoExpand = options.autoExpand;
        if (null != options.filterAttributes) request.filterAttributes = options.filterAttributes;
        if (!sync) request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var fullResult = WAF.DataStore.handleFuncResult(request, methodref, dataClass);
            var event = {
                result: fullResult.result
            };
            var err = fullResult.__ERROR;
            var userData = options.userData || null;
            event.XHR = request.http_request;
            WAF.callHandler(null != err, err, event, options, userData);
        };
        if (generateRESTRequestOnly) result = request.go({
            generateRESTRequestOnly: true
        }); else {
            request.go();
            if (sync) {
                var successCallback, failCallback;
                successCallback = function() {};
                failCallback = function() {};
                if (params.length > 0) {
                    if (params[0] && "function" == typeof params[0]) successCallback = params[0];
                    if (params[1] && "function" == typeof params[1]) failCallback = params[1];
                }
                if (4 != request.http_request.readyState) throw {
                    error: 401
                }; else {
                    var fullResult = WAF.DataStore.handleFuncResult(request, methodref, dataClass);
                    if (null != fullResult.__ERROR) {
                        failCallback(fullResult);
                        throw fullResult.__ERROR;
                    } else {
                        result = fullResult.result;
                        successCallback(result);
                    }
                }
            }
        }
        return result;
    };
    WAF.DataStore.callMethod = function(options) {
        var result = null;
        var em = this;
        var methodRef = em._private.dataClassMethodRefs[options.method];
        if (null != methodRef) {
            var myargs = [];
            if (null != options.arguments) myargs = options.arguments; else for (var i = 1, nb = arguments.length; i < nb; i++) myargs.push(arguments[i]);
            result = WAF.DataStore.funcCaller(methodRef, em, myargs, options);
        }
        return result;
    };
    WAF.DataStore.makeFuncCaller = function(methodRef) {
        var methodref = methodRef;
        var func = function() {
            var options;
            var alreadyParsedOptions = false;
            var myargs = [];
            for (var i = 0, nb = arguments.length; i < nb; i++) {
                var p = arguments[i];
                if (!alreadyParsedOptions && WAF.tools.isOptionParam(p)) {
                    options = p;
                    alreadyParsedOptions = true;
                } else myargs.push(p);
            }
            var xoptions = options || {};
            if (void 0 === xoptions.onSuccess && void 0 === xoptions.onError && void 0 === xoptions.generateRESTRequestOnly) xoptions.sync = true;
            return WAF.DataStore.funcCaller(methodref, this, myargs, xoptions);
        };
        return func;
    };
    WAF.DataStore.getCatalog = function(options, userData) {
        var priv = this;
        var dataStore = this.owner;
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        var merge = options.mergeCatalog || false;
        var alreadyDone = false;
        var catResource = "$all";
        priv.cacheRef = priv.cacheRef || options.cacheRef || false;
        if (null != options.catalog) {
            if ("string" == typeof options.catalog) catResource = options.catalog; else catResource = options.catalog.join(",");
            if (merge) {
                classList = catResource.split(",");
                newlist = [];
                classList.forEach(function(classname) {
                    if ("" != classname && null == dataStore[classname]) newlist.push(classname);
                });
                if (0 == newlist.length) alreadyDone = true;
            }
        }
        if (alreadyDone) {
            var event = {
                dataStore: dataStore,
                result: dataStore
            };
            WAF.callHandler(false, null, event, options, userData);
        } else {
            catResource = "$catalog/" + catResource;
            var request = new WAF.core.restConnect.restRequest(true);
            request.resource = catResource;
            request.handler = function() {
                if (4 != request.http_request.readyState) return;
                var error = false;
                var entitiesList = null;
                var err = null;
                try {
                    var result = WAF.getRequestResult(request);
                    if (result && result.dataClasses) entitiesList = result.dataClasses; else if (result && result.className) entitiesList = [ result ];
                    if (null == entitiesList) entitiesList = [];
                    if (null != result.__ERROR) {
                        error = true;
                        err = result.__ERROR;
                    }
                } catch (e) {
                    entitiesList = [];
                    error = true;
                    err = e;
                }
                for (var i = 0, nb = entitiesList.length; i < nb; i++) {
                    var dataClassInfo = entitiesList[i];
                    var emName = dataClassInfo.name;
                    if (null == dataStore[emName]) {
                        var collectionName = dataClassInfo.collectionName;
                        var dataClass = new WAF.DataClass(dataClassInfo, dataStore);
                        priv.dataClasses[emName] = dataClass;
                        if (null != collectionName) priv.dataClassesByCollectionName[collectionName] = dataClass;
                        dataStore[emName] = dataClass;
                    }
                }
                priv.ready = true;
                var event = {
                    dataStore: dataStore,
                    result: dataStore
                };
                event.XHR = request.http_request;
                WAF.callHandler(error, err, event, options, userData);
            };
            var errorFlag = request.go();
        }
    };
    WAF.DataClass = function(dataClassInfo, dataStore) {
        var dataClass = this, primaryKey = "";
        if (dataClassInfo.key) primaryKey = dataClassInfo.key[0].name;
        dataClass._private = {
            primaryKey: primaryKey,
            className: dataClassInfo.name,
            collectionName: dataClassInfo.collectionName,
            attributesByName: {},
            entityMethods: {},
            entityCollectionMethods: {},
            entityMethodRefs: {},
            entityCollectionMethodRefs: {},
            dataClassMethodRefs: {},
            owner: dataClass,
            dataStore: dataStore,
            cache: new WAF.EntityCache(),
            refCache: new WAF.EntityRefCache(),
            defaultTopSize: dataClassInfo.defaultTopSize,
            getEntityByURIOrKey: WAF.DataClass.getEntityByURIOrKey
        };
        var priv = dataClass._private;
        var attsByName = priv.attributesByName;
        var dataClassMethodRefs = priv.dataClassMethodRefs;
        var entityCollectionMethodRefs = priv.entityCollectionMethodRefs;
        var entityMethodRefs = priv.entityMethodRefs;
        var entityCollectionMethods = priv.entityCollectionMethods;
        var entityMethods = priv.entityMethods;
        var attributes = dataClassInfo.attributes;
        var methods = dataClassInfo.methods;
        priv.methods = methods;
        if (null != attributes) for (var j = 0, nbatt = attributes.length; j < nbatt; j++) {
            var att = attributes[j];
            att.owner = dataClass;
            attsByName[att.name] = att;
            if ("storage" == att.kind || "calculated" == att.kind || "alias" == att.kind || "composition" == att.kind) {
                att.simple = true;
                att.related = false;
                if ("image" == att.type || "blob" == att.type) att.simple = false;
            } else {
                att.simple = false;
                att.related = true;
                att.resolved = false;
                att.relatedOne = "relatedEntity" == att.kind;
                att.resolve = WAF.DataStore.resolveRelatedAttribute;
                att.getRelatedClass = WAF.DataStore.getRelatedClassAttribute;
                att.relatedClass = null;
            }
            dataClass[att.name] = att;
        }
        priv.attributes = attributes;
        var methlist = methods;
        if (null != methlist) for (var j = 0, nbmethod = methlist.length; j < nbmethod; j++) {
            var methodRef = methlist[j];
            if ("entity" == methodRef.applyTo) {
                entityMethodRefs[methodRef.name] = methodRef;
                entityMethods[methodRef.name] = WAF.DataStore.makeFuncCaller(methodRef);
            } else if ("entityCollection" == methodRef.applyTo) {
                entityCollectionMethodRefs[methodRef.name] = methodRef;
                entityCollectionMethods[methodRef.name] = WAF.DataStore.makeFuncCaller(methodRef);
            } else {
                dataClassMethodRefs[methodRef.name] = methodRef;
                dataClass[methodRef.name] = WAF.DataStore.makeFuncCaller(methodRef);
            }
        }
        return this;
    };
    WAF.DataClass.getEntityByURIOrKey = function(key, dataURI, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 2);
        userData = resOp.userData;
        options = resOp.options;
        var priv = this;
        var dataClass = priv.owner;
        var request = new WAF.core.restConnect.restRequest(true);
        if (null != dataURI) request.fullURL = dataURI; else request.resource = dataClass.getName() + "(" + key + ")";
        request.autoExpand = options.autoExpand;
        request.autoSubExpand = options.autoSubExpand;
        request.filterAttributes = options.filterAttributes;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var error = false;
            var err = null;
            var result = WAF.getRequestResult(request);
            if (null != result.__ERROR) {
                error = true;
                err = result.__ERROR;
            }
            var entity = null;
            if (!error) {
                var cacheRef = dataClass.mustCacheRef();
                entity = new WAF.Entity(dataClass, result, {
                    getRefFromCache: cacheRef
                });
                if (!cacheRef) {
                    var key = entity.getKey();
                    var cache = dataClass.getCache();
                    var cacheInfo = cache.getCacheInfo(key);
                    if (null == cacheInfo) {
                        var timeStamp = new Date();
                        cache.setEntry(key, result, timeStamp);
                    } else cache.replaceCachedEntity(key, result);
                }
            }
            var event = {
                entity: entity,
                result: entity
            };
            event.XHR = request.http_request;
            WAF.callHandler(error, err, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.DataClass.mustCacheRef = function() {
        return this._private.dataStore.mustCacheRef();
    };
    WAF.DataClass.getName = function() {
        return this._private.className;
    };
    WAF.DataClass.getCollectionName = function() {
        return this._private.collectionName;
    };
    WAF.DataClass.getDefaultTopSize = function() {
        return this._private.defaultTopSize;
    };
    WAF.DataClass.getDataStore = function() {
        return this._private.dataStore;
    };
    WAF.DataClass.getCache = function() {
        return this._private.cache;
    };
    WAF.DataClass.getRefCache = function() {
        return this._private.refCache;
    };
    WAF.DataClass.setCacheSize = function(nbEntries) {
        var cache = this._private.cacheRef ? this._private.refCache : this._private.cache;
        cache.setSize(nbEntries);
    };
    WAF.DataClass.getCacheSize = function() {
        var cache = this._private.cacheRef ? this._private.refCache : this._private.cache;
        return cache.maxEntities;
    };
    WAF.DataClass.clearCache = function() {
        var cache = this._private.cacheRef ? this._private.refCache : this._private.cache;
        cache.clear();
    };
    WAF.DataClass.getAttributeByName = function(attName) {
        var dataClass = this;
        return dataClass._private.attributesByName[attName];
    };
    WAF.DataClass.getAttributes = function() {
        var dataClass = this;
        return dataClass._private.attributes;
    };
    WAF.DataClass.getMethodList = function() {
        var dataClass = this;
        return dataClass._private.methods;
    };
    WAF.DataClass.newEntity = function() {
        var entity = new WAF.Entity(this);
        return entity;
    };
    WAF.DataClass.getEntity = function(key, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        if (dataClass.mustCacheRef()) {
            var cache = dataClass.getRefCache();
            var cacheInfo;
            if (options.forceReload) cacheInfo = null; else cacheInfo = cache.getCacheInfo(key);
            if (null == cacheInfo) dataClass._private.getEntityByURIOrKey(key, null, options, userData); else {
                var entity = cacheInfo.entity;
                var event = {
                    entity: entity,
                    result: entity
                };
                var result = WAF.callHandler(false, null, event, options, userData);
                if ("boolean" == typeof result) if (!result) if (null != options) options.mustStopLoop = true;
            }
        } else {
            var cache = dataClass.getCache();
            var cacheInfo;
            if (options.forceReload) cacheInfo = null; else cacheInfo = cache.getCacheInfo(key);
            if (null == cacheInfo || null == cacheInfo.rawEntity) dataClass._private.getEntityByURIOrKey(key, null, options, userData); else {
                var entity = new WAF.Entity(dataClass, cacheInfo.rawEntity);
                var event = {
                    entity: entity,
                    result: entity
                };
                var result = WAF.callHandler(false, null, event, options, userData);
                if ("boolean" == typeof result) if (!result) if (null != options) options.mustStopLoop = true;
            }
        }
    };
    WAF.DataClass.newCollection = function(collectionReference, options, userData) {
        if (null == collectionReference) {
            var collection = new WAF.EntityCollection(this, null, {
                createEmptyCollection: true
            });
            return collection;
        } else {
            var resOp = WAF.tools.handleArgs(arguments, 1);
            userData = resOp.userData;
            options = resOp.options;
            options.dataURI = collectionReference.dataURI;
            options.pageSize = options.pageSize || collectionReference.pageSize;
            options.autoExpand = options.autoExpand || collectionReference.autoExpand;
            options.filterAttributes = options.filterAttributes || collectionReference.filterAttributes;
            options.savedQuery = collectionReference.savedQuery || null;
            options.savedOrderby = collectionReference.savedOrderby || null;
            var collection = new WAF.EntityCollection(this, null, options, userData);
            return collection;
        }
    };
    WAF.DataClass.getEntityByURI = function(dataURI, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        dataClass._private.getEntityByURIOrKey(null, dataURI, options, userData);
    };
    WAF.DataClass.distinctValues = function(attributeName, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var queryString = options.queryString;
        var skip = options.skip;
        var top = options.top;
        var dataClass = this;
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = dataClass.getName();
        request.filter = queryString;
        request.skip = skip;
        request.top = top;
        request.options = {
            objectRef: this,
            first: skip,
            top: top
        };
        if (null != attributeName) request.attributesRequested = [ attributeName ];
        request.distinct = true;
        request.addToSet = options.addToSet;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var withError = false;
            var err = null;
            if (null != rawResult.__ERROR) {
                err = rawResult.__ERROR;
                withError = true;
                for (var ierr = 0; ierr < rawResult.__ERROR.length; ierr++) {
                    var rawerr = rawResult.__ERROR[ierr];
                    if (null == rawerr.options) rawerr.options = {};
                    rawerr.options.position = first;
                }
            }
            var event = {
                result: rawResult,
                distinctValues: rawResult,
                XHR: request.http_request
            };
            WAF.callHandler(withError, err, event, options, userData);
        };
        request.go();
    };
    WAF.DataClass.query = function(queryString, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1, {
            queryParams: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        var entityCollection = new WAF.EntityCollection(dataClass, queryString, options, userData);
        return entityCollection;
    };
    WAF.DataClass.allEntities = function(options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        return this.query("", options, userData);
    };
    WAF.DataClass.find = function(queryString, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1, {
            queryParams: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        var priv = this._private;
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = dataClass.getName();
        request.autoExpand = options.autoExpand;
        request.filterAttributes = options.filterAttributes;
        request.filter = queryString;
        request.top = 1;
        request.orderby = options.orderby;
        request.params = options.params;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var error = false;
            var err = null;
            var result = WAF.getRequestResult(request);
            if (null != result.__ERROR) {
                error = true;
                err = result.__ERROR;
            }
            var entity = null;
            if (!error && null != result.__ENTITIES && result.__ENTITIES.length > 0) entity = new WAF.Entity(dataClass, result.__ENTITIES[0], {
                getRefFromCache: true
            });
            var event = {
                entity: entity,
                result: entity,
                XHR: request.http_request
            };
            WAF.callHandler(error, err, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.DataClass.toArray = function(attributeList, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = this.getName();
        request.top = options.top || null;
        request.skip = options.skip || null;
        request.addToSet = options.addToSet;
        request.retainPositions = options.retainPositions || null;
        request.progressInfo = options.progressInfo;
        request.orderby = options.orderby;
        request.autoExpand = attributeList;
        request.asArray = true;
        if (options.filterQuery) {
            request.filter = options.filterQuery;
            request.params = options.params;
        }
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                dataClass: dataClass,
                result: rawResult,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollectionPage = function(start, length) {
        var page = this;
        this.start = start;
        this.length = length;
        this.entityKeys = [];
    };
    WAF.EntityCollection = function(dataClass, queryString, options, userData) {
        if ("''" == queryString || "" == queryString) queryString = null;
        var resOp = WAF.tools.handleArgs(arguments, 2);
        userData = resOp.userData;
        options = resOp.options;
        var dejaSet = options.filterSet;
        var savedQuery;
        if (null != dejaSet) {
            savedQuery = dejaSet._private.savedQuery;
            if (null != savedQuery) {
                if (null != queryString) savedQuery = "(" + savedQuery + ") and " + queryString;
            } else saveQuery = queryString;
        } else savedQuery = queryString;
        if (null == savedQuery) savedQuery = options.savedQuery || null;
        if (null == options.orderby && null != options.orderBy) options.orderby = options.orderBy;
        var savedOrderby = options.orderby || null;
        if (null == savedOrderby) savedOrderby = options.savedOrderby || null;
        var pageSize = options.pageSize || 40;
        var entityCollection = this;
        this._private = {
            ready: false,
            owner: this,
            queryString: queryString,
            savedQuery: savedQuery,
            orderby: savedOrderby,
            savedOrderby: savedOrderby,
            dataURI: options.dataURI,
            pageSize: pageSize,
            withQueryPlan: options.queryPlan,
            withQueryPath: options.queryPath,
            progressInfo: options.progressInfo,
            params: options.params,
            dataClass: dataClass,
            methodRefs: dataClass._private.entityCollectionMethodRefs,
            methods: dataClass._private.entityCollectionMethods,
            autoExpand: options.autoExpand,
            autoSubExpand: options.autoSubExpand,
            filterAttributes: options.filterAttributes,
            isMethodResult: options.isMethodResult,
            isARelatedEntityCollection: options.isARelatedEntityCollection,
            loadedElemsLength: 0,
            addedElems: [],
            curPendingStamp: 0,
            pendingRequests: {},
            pages: [],
            clearCache: WAF.EntityCollection.clearCache,
            insertPage: WAF.EntityCollection.insertPage,
            findPage: WAF.EntityCollection.findPage,
            invalidPage: WAF.EntityCollection.invalidPage,
            getKeyByPos: WAF.EntityCollection.getKeyByPos,
            manageData: WAF.EntityCollection.manageData,
            fetchData: WAF.EntityCollection.fetchData,
            addPendingRequest: WAF.EntityCollection.addPendingRequest,
            clearPendingRequest: WAF.EntityCollection.clearPendingRequest,
            clearAllPendingRequest: WAF.EntityCollection.clearAllPendingRequest,
            isPagePending: WAF.EntityCollection.isPagePending,
            gotEntity: WAF.EntityCollection.gotEntity,
            updateOptions: WAF.EntityCollection.updateOptions
        };
        var priv = this._private;
        var methods = priv.methods;
        for (var e in methods) entityCollection[e] = methods[e];
        this.length = 0;
        options.init = true;
        if (options.createEmptyCollection) {
            priv.ready = true;
            queryString = "*";
        } else if (null != options.dataURI && "*" == options.dataURI) priv.ready = true; else if (null != options.prefetchedData) entityCollection._private.manageData(options.prefetchedData, true); else {
            if (null == queryString && null == priv.savedQuery) priv.savedQuery = "$all";
            entityCollection._private.fetchData(0, pageSize, options, userData);
        }
        return entityCollection;
    };
    WAF.EntityCollection.clearCache = function() {
        var priv = this;
        priv.pages = [];
    };
    WAF.EntityCollection.insertPage = function(page) {
        var priv = this;
        var pages = priv.pages;
        var nbpages = pages.length;
        if (0 == nbpages) pages.push(page); else {
            var posToInsert = -1;
            for (var i = 0; i < nbpages; i++) {
                var xpage = pages[i];
                if (xpage.start > page.start) {
                    posToInsert = i;
                    break;
                }
            }
            if (posToInsert == -1) pages.push(page); else pages.splice(posToInsert, 0, page);
        }
    };
    WAF.EntityCollection.findPage = function(pos) {
        var priv = this;
        var pages = priv.pages;
        var nbpages = pages.length;
        var low = 0;
        var high = nbpages;
        while (high > low) {
            var middle = Math.floor((high - low) / 2) + low;
            var page = pages[middle];
            if (page.start <= pos && page.start + page.length > pos) return middle; else if (pos < page.start) high = middle; else low = middle + 1;
        }
        return -1;
    };
    WAF.EntityCollection.invalidPage = function(pos) {
        var priv = this;
        var pagePos = priv.findPage(pos);
        if (pagePos != -1) priv.pages.splice(pagePos, 1);
    };
    WAF.EntityCollection.getKeyByPos = function(pos) {
        var result = null;
        var priv = this;
        var pagePos = priv.findPage(pos);
        if (pagePos != -1) {
            var page = priv.pages[pagePos];
            var keyElem = page.entityKeys[pos - page.start];
            result = keyElem.key;
        }
        return result;
    };
    WAF.EntityCollection.addPendingRequest = function(start, length) {
        var priv = this;
        priv.curPendingStamp++;
        priv.pendingRequests[priv.curPendingStamp] = {
            start: start,
            length: length
        };
        return priv.curPendingStamp;
    };
    WAF.EntityCollection.clearPendingRequest = function(pendingStamp) {
        var priv = this;
        delete priv.pendingRequests[pendingStamp];
    };
    WAF.EntityCollection.clearAllPendingRequest = function() {
        var priv = this;
        for (var e in priv.pendingRequests) priv.pendingRequests[e];
    };
    WAF.EntityCollection.isPagePending = function(pos) {
        var priv = this;
        for (var e in priv.pendingRequests) {
            var pendingRequest = priv.pendingRequests[e];
            if (pendingRequest.start <= pos && pendingRequest.start + pendingRequest.length > pos) return true;
        }
        return false;
    };
    WAF.EntityCollection.manageData = function(rawResult, init) {
        var priv = this;
        var entityCollection = this.owner;
        var dataClass = entityCollection.getDataClass();
        var cache;
        init = init || false;
        if (init) {
            entityCollection.length = rawResult.__COUNT;
            priv.ready = true;
            priv.loadedElemsLength = entityCollection.length;
            priv.dataURI = rawResult.__ENTITYSET;
            if (null != priv.autoSubExpand) {
                priv.autoExpand = priv.autoSubExpand;
                priv.autoSubExpand = null;
            }
        }
        var nbEnts = rawResult.__SENT;
        var first = rawResult.__FIRST;
        var arr = rawResult.__ENTITIES;
        var timeStamp = new Date();
        var page = new WAF.EntityCollectionPage(first, nbEnts);
        var cacheref = dataClass.mustCacheRef();
        if (cacheref) cache = dataClass.getRefCache(); else cache = dataClass.getCache();
        cache.makeRoomFor(nbEnts);
        for (var i = 0; i < nbEnts; i++) {
            var rawEntity = arr[i];
            var xkey;
            if (null == rawEntity) {
                if (!cacheref) cache.setEntry("", {
                    __STAMP: 0
                }, timeStamp);
                xkey = "";
            } else {
                var stamp = -1;
                xkey = rawEntity.__KEY;
                if (null == xkey) xkey = "";
                if (cacheref) var entity = new WAF.Entity(dataClass, rawEntity, {
                    getRefFromCache: true
                }); else stamp = cache.setEntry(xkey, rawEntity, timeStamp);
            }
            page.entityKeys.push({
                key: rawEntity.__KEY,
                stamp: stamp
            });
        }
        priv.insertPage(page);
    };
    WAF.EntityCollection.fetchData = function(skip, top, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 2);
        userData = resOp.userData;
        options = resOp.options;
        var dejaSet = options.filterSet;
        var init = options.init || false;
        var priv = this;
        var entityCollection = this.owner;
        var dataClass = entityCollection.getDataClass();
        var cache = dataClass.getCache();
        var pendingStamp = priv.addPendingRequest(skip, top);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getName();
        if (null != dejaSet) if (null != dejaSet._private.dataURI) {
            request.dataURI = dejaSet._private.dataURI;
            request.filter = priv.queryString;
        } else request.filter = priv.savedQuery; else request.filter = priv.queryString;
        request.top = top;
        request.skip = skip;
        request.attributesRequested = null;
        request.attributesExpanded = null;
        request.autoExpand = priv.autoExpand;
        request.autoSubExpand = priv.autoSubExpand;
        request.filterAttributes = priv.filterAttributes;
        request.params = priv.params;
        if (priv.mustRefreshCollectionOnNextFetch) {
            request.refreshOnly = true;
            priv.mustRefreshCollectionOnNextFetch = false;
        }
        if (options.fromSelection) request.fromSelection = options.fromSelection;
        if (init) {
            request.removeAtPos = options.removeAtPos;
            request.removeReferenceOnly = options.removeReferenceOnly;
            request.addToSet = options.addToSet;
            var sel = request.fromSelection;
            if (null != sel) request.fromSelection = sel.prepareToSend();
        }
        request.queryPlan = priv.withQueryPlan;
        request.progressInfo = priv.progressInfo;
        if (priv.isARelatedEntityCollection) request.method = "subentityset"; else request.method = "entityset";
        request.timeout = options.timeout || 300;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = request.dataURI || priv.dataURI;
        if (request.dataURI && null == dejaSet) request.filter = null;
        request.orderby = options.orderby;
        request.subOrderby = options.subOrderby;
        request.keepSelection = options.keepSelection;
        request.reselect = options.reselect;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            priv.clearPendingRequest(pendingStamp);
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                result: entityCollection,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            if (!withError) {
                if (null != rawResult.__transformedSelection) event.transformedSelection = rawResult.__transformedSelection;
                priv.manageData(rawResult, init);
            }
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.updateOptions = function(options) {
        var priv = this;
        if (priv.addedElems.length > 0) {
            var addedKeys = [];
            for (var i = 0, nbelem = priv.addedElems.length; i < nbelem; i++) {
                var e = priv.addedElems[i];
                var key = null;
                if (null != e && e.getKey) key = e.getKey();
                if (null != key) addedKeys.push(key);
            }
            if (addedKeys.length > 0) options.addToSet = addedKeys;
        }
    };
    WAF.EntityCollection.getDataClass = function() {
        var entityCollection = this;
        return entityCollection._private.dataClass;
    };
    WAF.EntityCollection.getReference = function() {
        var result = null;
        var entityCollection = this;
        var priv = entityCollection._private;
        if (null != priv.dataURI) {
            result = {
                dataURI: priv.dataURI
            };
            if (null != priv.savedQuery) result.savedQuery = priv.savedQuery;
            if (null != priv.savedOrderby) result.savedOrderby = priv.savedOrderby;
            if (null != priv.pageSize) result.pageSize = priv.pageSize;
            if (null != priv.autoExpand) result.autoExpand = priv.autoExpand;
        }
        return result;
    };
    WAF.EntityCollection.query = function(queryString, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1, {
            queryParams: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        options.filterSet = entityCollection;
        var dataClass = entityCollection.getDataClass();
        options.pageSize = options.pageSize || entityCollection._private.pageSize;
        options.autoExpand = options.autoExpand || entityCollection._private.autoExpand;
        options.filterAttributes = options.filterAttributes || entityCollection._private.filterAttributes;
        entityCollection._private.updateOptions(options);
        var subEntityCollection = new WAF.EntityCollection(dataClass, queryString, options, userData);
        return subEntityCollection;
    };
    WAF.EntityCollection.orderBy = function(orderByString, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        if (0 == this.length) {
            var event = {
                entityCollection: entityCollection,
                result: entityCollection
            };
            WAF.callHandler(false, null, event, options, userData);
            return entityCollection;
        } else {
            options.orderby = orderByString;
            var priv = entityCollection._private;
            options.dataURI = priv.dataURI;
            var dataClass = entityCollection.getDataClass();
            options.pageSize = options.pageSize || priv.pageSize;
            options.autoExpand = options.autoExpand || priv.autoExpand;
            options.filterAttributes = options.filterAttributes || priv.filterAttributes;
            priv.updateOptions(options);
            options.savedQuery = priv.savedQuery || null;
            var subEntityCollection = new WAF.EntityCollection(dataClass, null, options, userData);
            return subEntityCollection;
        }
    };
    WAF.EntityCollection.getEntities = function(pos, howMany, options, userData) {
        var entityCollection = this;
        var priv = entityCollection._private;
        if (priv.ready) {
            if (pos + howMany > entityCollection.length) howMany = entityCollection.length - pos;
            var resOp = WAF.tools.handleArgs(arguments, 2);
            userData = resOp.userData;
            options = resOp.options;
            var lenFromServer = priv.loadedElemsLength;
            var lenLocal = priv.addedElems.length;
            var dataClass = entityCollection.getDataClass();
            priv.updateOptions(options);
            var result = [];
            var newevent = {
                entityCollection: entityCollection,
                result: entityCollection,
                position: pos,
                howMany: howMany,
                entities: result
            };
            var errorOccured = null;
            entityCollection.forEach({
                first: pos,
                limit: pos + howMany,
                onSuccess: function(ev) {
                    result.push(ev.entity);
                },
                onError: function(ev) {
                    errorOccured = ev.error;
                },
                atTheEnd: function(ev) {
                    if (null != errorOccured) WAF.callHandler(true, errorOccured, newevent, options, userData); else WAF.callHandler(false, null, newevent, options, userData);
                }
            });
        } else setTimeout(function() {
            entityCollection.getEntities(pos, howMany, options, userData);
        }, 100);
    };
    WAF.EntityCollection.getEntity = function(pos, options, userData, doNotFetch) {
        var executed = false;
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var forceCollectionRefresh = null != options && (options.forceCollectionRefresh || false);
        if (resOp.nextParam < arguments.length) doNotFetch = arguments[resOp.nextParam] || false; else doNotFetch = false;
        var entityCollection = this;
        var priv = entityCollection._private;
        var lenToCheck = priv.loadedElemsLength;
        if (forceCollectionRefresh) {
            priv.clearAllPendingRequest();
            priv.clearCache();
            priv.mustRefreshCollectionOnNextFetch = true;
            lenToCheck = entityCollection.length;
        }
        var dataClass = entityCollection.getDataClass();
        if (pos >= lenToCheck) {
            executed = true;
            var newevent = {
                entityCollection: entityCollection,
                result: entityCollection,
                position: pos
            };
            var subpos = pos - priv.loadedElemsLength;
            if (subpos < priv.addedElems.length) {
                newevent.entity = priv.addedElems[subpos];
                WAF.callHandler(false, null, newevent, options, userData);
            } else if (forceCollectionRefresh) WAF.callHandler(false, null, newevent, options, userData); else WAF.callHandler(true, [ {
                error: 501,
                message: "wrong position in entityCollection"
            } ], newevent, options, userData);
        } else {
            var okfetch = false;
            var key = priv.getKeyByPos(pos);
            if (null == key && !doNotFetch) if (priv.isPagePending(pos)) setTimeout(function() {
                entityCollection.getEntity(pos, options, userData);
            }, 100); else okfetch = true;
            if (null != key) {
                var cacheRef = dataClass.mustCacheRef();
                var cache;
                if (cacheRef) cache = dataClass.getRefCache(); else cache = dataClass.getCache();
                var cacheInfo = cache.getCacheInfo(key);
                if (null != cacheInfo) {
                    executed = true;
                    priv.gotEntity(cacheInfo, options, userData, pos);
                } else {
                    okfetch = true;
                    key = null;
                    priv.invalidPage(pos);
                }
            }
            if (doNotFetch) okfetch = false;
            if (null == key && okfetch) {
                var delay, delayInfo;
                if (null != options) {
                    delay = options.delay;
                    delayInfo = options.delayInfo;
                } else {
                    delay = null;
                    delayInfo = null;
                }
                if (null != delay && 0 != delay && null != delayInfo) {
                    var delayReq = delayInfo.findMatchingPendingRequest(pos);
                    if (null == delayReq) {
                        var posbefore = pos - 20;
                        if (posbefore < 0) posbefore = 0;
                        delayReq = delayInfo.addPendingRequest(0, posbefore, pos + priv.pageSize - 1);
                        delayReq.addFetchRequest(pos, options, userData);
                        var requestid = setTimeout(function() {
                            if (delayReq.matchRange(delayInfo.top, delayInfo.bottom)) {
                                var newOptions = {};
                                if (forceCollectionRefresh) priv.updateOptions(newOptions);
                                priv.fetchData(delayReq.top, delayReq.bottom - delayReq.top + 1, {
                                    onSuccess: function(event) {
                                        if (forceCollectionRefresh) priv.addedElems = [];
                                        delayReq.pendingFetch.forEach(function(fetchItem) {
                                            if (fetchItem.pos >= delayInfo.top && fetchItem.pos <= delayInfo.bottom) {
                                                var key = priv.getKeyByPos(fetchItem.pos);
                                                var cacheRef = dataClass.mustCacheRef();
                                                var cache;
                                                if (cacheRef) cache = dataClass.getRefCache(); else cache = dataClass.getCache();
                                                var cacheInfo = cache.getCacheInfo(key);
                                                if (null != cacheInfo) priv.gotEntity(cacheInfo, fetchItem.options, fetchItem.userData, fetchItem.pos); else priv.gotEntity(null, fetchItem.options, fetchItem.userData);
                                            }
                                        });
                                        delayInfo.removePendingRequest(delayReq);
                                    },
                                    onError: function(event) {
                                        delayReq.pendingFetch.forEach(function(fetchItem) {
                                            if (fetchItem.pos >= delayInfo.top && fetchItem.pos <= delayInfo.bottom) {
                                                var newevent = {
                                                    entityCollection: entityCollection,
                                                    result: entityCollection,
                                                    position: fetchItem.pos,
                                                    entity: null
                                                };
                                                WAF.callHandler(true, event.error, newevent, fetchItem.options, fetchItem.userData);
                                            }
                                        });
                                        delayInfo.removePendingRequest(delayReq);
                                    },
                                    init: forceCollectionRefresh,
                                    addToSet: newOptions.addToSet || null
                                });
                            } else delayInfo.removePendingRequest(delayReq);
                        }, delay);
                        delayReq.setRequestID(requestid);
                    } else delayReq.addFetchRequest(pos, options, userData);
                } else {
                    var newOptions = {};
                    if (forceCollectionRefresh) priv.updateOptions(newOptions);
                    priv.fetchData(pos, priv.pageSize, {
                        onSuccess: function(event) {
                            if (forceCollectionRefresh) priv.addedElems = [];
                            var key = priv.getKeyByPos(pos);
                            var cacheRef = dataClass.mustCacheRef();
                            var cache;
                            if (cacheRef) cache = dataClass.getRefCache(); else cache = dataClass.getCache();
                            var cacheInfo = cache.getCacheInfo(key);
                            if (null != cacheInfo) priv.gotEntity(cacheInfo, options, userData, pos); else priv.gotEntity(null, options, userData);
                        },
                        onError: function(event) {
                            var newevent = {
                                entityCollection: entityCollection,
                                result: entityCollection,
                                position: pos,
                                entity: null
                            };
                            WAF.callHandler(true, event.error, newevent, options, userData);
                        },
                        init: forceCollectionRefresh,
                        addToSet: newOptions.addToSet || null
                    });
                }
            }
        }
        return executed;
    };
    WAF.EntityCollection.gotEntity = function(cacheInfo, options, userData, position) {
        var priv = this;
        var entityCollection = priv.owner;
        var entity;
        if (null != cacheInfo) if (null != cacheInfo.entity) entity = cacheInfo.entity; else entity = new WAF.Entity(entityCollection.getDataClass(), cacheInfo.rawEntity, {
            getRefFromCache: true
        }); else entity = null;
        var event = {
            entityCollection: entityCollection,
            result: entity,
            entity: entity,
            position: position
        };
        WAF.callHandler(false, null, event, options, userData);
    };
    WAF.EntityCollection.callMethod = function(options) {
        var entityCollection = this;
        var methodRef = entityCollection._private.methodRefs[options.method];
        if (null != methodRef) {
            var myargs = [];
            if (null != options.arguments) myargs = options.arguments; else for (var i = 1, nb = arguments.length; i < nb; i++) myargs.push(arguments[i]);
            return WAF.DataStore.funcCaller(methodRef, entityCollection, myargs, options);
        }
    };
    WAF.EntityCollection.parseForEach = function(options, parseData) {
        var executed = true;
        var entityCollection = parseData.entityCollection;
        var priv = entityCollection._private;
        var stop = false;
        while (executed && parseData.curelem < parseData.limit && !stop) {
            executed = entityCollection.getEntity(parseData.curelem, options, parseData.userData, true);
            if (null != options && options.mustStopLoop) stop = true; else if (executed) parseData.curelem++; else entityCollection.getEntity(parseData.curelem, {
                onSuccess: function(event) {
                    WAF.EntityCollection.parseForEach(options, parseData);
                },
                onError: function(event) {
                    WAF.callHandler(true, event.error, event, options, parseData.userData);
                }
            }, parseData);
        }
        if (executed) if (null != options.atTheEnd) {
            var event = {
                entityCollection: entityCollection,
                userData: parseData.userData
            };
            options.atTheEnd(event);
        }
        return executed;
    };
    WAF.EntityCollection.forEach = function(options, userData) {
        var entityCollection = this;
        var priv = entityCollection._private;
        var resOp = WAF.tools.handleArgs(arguments, 0, {
            with3funcs: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var parseInfo = {
            curelem: options.first || 0,
            limit: options.limit || entityCollection.length,
            userData: userData,
            entityCollection: entityCollection
        };
        WAF.EntityCollection.parseForEach(options, parseInfo);
    };
    WAF.EntityCollection.forEachInCache = function(options, userData) {
        var entityCollection = this;
        var priv = entityCollection._private;
        var resOp = WAF.tools.handleArgs(arguments, 0, {
            with3funcs: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var stop = false;
        var curpagenum = -1;
        var nbpage = priv.pages.length;
        var curelem = 0;
        var nbelem = 0;
        var curpage = null;
        var curstart = 0;
        var absolutestart = options.first || 0;
        var absoluteend = options.limit || entityCollection.length;
        while (!stop) {
            if (curelem >= nbelem) {
                ++curpagenum;
                if (curpagenum >= nbpage) stop = true; else {
                    curpage = priv.pages[curpagenum];
                    nbelem = curpage.length;
                    curelem = 0;
                    curstart = curpage.start;
                }
            } else ++curelem;
            if (!stop) {
                var pos = curstart + curelem;
                if (pos >= absolutestart) if (pos < absoluteend) entityCollection.getEntity(pos, options, userData, true); else stop = true;
            }
        }
    };
    WAF.EntityCollection.add = function(entity) {
        if (null != entity) {
            this._private.addedElems.push(entity);
            this.length++;
        }
    };
    WAF.EntityCollection.refresh = function(options, userData) {
        options = options || {};
        options.forceCollectionRefresh = true;
        var from = 0;
        if (null != options.refreshCollectionFrom) from = options.refreshCollectionFrom;
        userData = userData;
        this.getEntity(from, options, userData);
    };
    WAF.EntityCollection.toArray = function(attributeList, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        priv.updateOptions(options);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getName();
        request.top = options.top || priv.pageSize || 40;
        request.skip = options.skip || null;
        request.params = priv.params;
        request.addToSet = options.addToSet;
        request.retainPositions = options.retainPositions || null;
        request.progressInfo = options.progressInfo || priv.progressInfo;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = priv.dataURI;
        request.orderby = options.orderby;
        request.autoExpand = attributeList;
        request.asArray = true;
        if (options.filterQuery) {
            request.filter = options.filterQuery;
            request.params = options.params;
        }
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                result: rawResult,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.distinctValues = function(attributeName, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        priv.updateOptions(options);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getName();
        request.addToSet = options.addToSet;
        request.top = options.top || null;
        request.skip = options.skip || null;
        request.params = priv.params;
        request.progressInfo = options.progressInfo || priv.progressInfo;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = priv.dataURI;
        request.distinct = true;
        if (null != attributeName) request.attributesRequested = [ attributeName ];
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                distinctValues: rawResult,
                result: rawResult,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.findKey = function(key, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        priv.updateOptions(options);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getName();
        request.addToSet = options.addToSet;
        request.top = options.top || null;
        request.skip = options.skip || null;
        request.params = priv.params;
        request.progressInfo = options.progressInfo || priv.progressInfo;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = priv.dataURI;
        if (key instanceof Date) key = key.toISO();
        request.findKey = key;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                result: rawResult.result,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.removeEntityReference = function(posInSet, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        options.removeReferenceOnly = true;
        this.removeEntity(posInSet, options, userData);
    };
    WAF.EntityCollection.removeEntity = function(posInSet, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        options.dataURI = priv.dataURI;
        var dataClass = entityCollection.getDataClass();
        if (posInSet >= priv.loadedElemsLength && posInSet < entityCollection.length) {
            var subpos = posInSet - priv.loadedElemsLength;
            var entity = priv.addedElems[subpos];
            var resev = {
                entityCollection: entityCollection,
                result: entityCollection
            };
            if (null == entity || null == entity.getKey() || options.removeReferenceOnly) {
                priv.addedElems.splice(subpos, 1);
                entityCollection.length--;
                WAF.callHandler(false, null, resev, options, userData);
            } else entity.remove({
                onSuccess: function(ev) {
                    priv.addedElems.splice(subpos, 1);
                    entityCollection.length--;
                    WAF.callHandler(false, null, resev, options, userData);
                },
                onError: function(ev) {
                    WAF.callHandler(true, ev.error, resev, options, userData);
                }
            });
        } else {
            options.pageSize = options.pageSize || priv.pageSize;
            options.autoExpand = options.autoExpand || priv.autoExpand;
            options.filterAttributes = options.filterAttributes || priv.filterAttributes;
            priv.updateOptions(options);
            options.removeAtPos = posInSet;
            options.savedQuery = priv.savedQuery || null;
            options.savedOrderby = priv.savedOrderby || null;
            var newEntityCollection = new WAF.EntityCollection(dataClass, null, options, userData);
            return newEntityCollection;
        }
    };
    WAF.EntityCollection.removeAllEntities = function(options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        priv.updateOptions(options);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getName();
        request.addToSet = options.addToSet;
        request.params = priv.params;
        request.progressInfo = options.progressInfo || priv.progressInfo;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = priv.dataURI;
        request.method = "delete";
        request.atOnce = options.atOnce;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.buildFromSelection = function(selection, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        var dataClass = entityCollection.getDataClass();
        options.pageSize = options.pageSize || priv.pageSize;
        options.autoExpand = options.autoExpand || priv.autoExpand;
        options.filterAttributes = options.filterAttributes || priv.filterAttributes;
        priv.updateOptions(options);
        options.filterSet = entityCollection;
        options.fromSelection = selection;
        options.savedQuery = priv.savedQuery || null;
        options.savedOrderby = priv.savedOrderby || null;
        var subEntityCollection = new WAF.EntityCollection(dataClass, null, options, userData);
        return subEntityCollection;
    };
    WAF.EntityAttributeSimple = function(entity, rawVal, att) {
        this.owner = entity;
        if ("date" == att.type && "string" == typeof rawVal) if (att.simpleDate) this.value = stringToSimpleDate(rawVal); else this.value = ISOToDate(rawVal); else this.value = rawVal;
        this.touched = false;
        this.att = att;
        this.getValue = WAF.EntityAttributeSimple.getValue;
        this.setValue = WAF.EntityAttributeSimple.setValue;
        this.touch = WAF.EntityAttributeSimple.touch;
        this.isTouched = WAF.EntityAttributeSimple.isTouched;
        this.clearTouched = WAF.EntityAttributeSimple.clearTouched;
        this.getOldValue = WAF.EntityAttributeSimple.getOldValue;
        this.setRawValue = WAF.EntityAttributeSimple.setRawValue;
        this.getRawValue = WAF.EntityAttributeSimple.getRawValue;
    };
    WAF.EntityAttributeSimple.getValue = function() {
        return this.value;
    };
    WAF.EntityAttributeSimple.setValue = function(val) {
        if (void 0 === this.oldValue) this.oldValue = this.value;
        this.value = val;
        this.touch();
    };
    WAF.EntityAttributeSimple.touch = function() {
        this.touched = true;
        this.owner.touch();
    };
    WAF.EntityAttributeSimple.clearTouched = function() {
        this.touched = false;
    };
    WAF.EntityAttributeSimple.isTouched = function() {
        return this.touched;
    };
    WAF.EntityAttributeSimple.getOldValue = function() {
        if (void 0 === this.oldValue) return this.getValue(); else return this.oldValue;
    };
    WAF.EntityAttributeSimple.setRawValue = function(rawVal) {
        if ("date" === this.att.type && "string" === typeof rawVal) if (this.att.simpleDate) this.value = stringToSimpleDate(rawVal); else this.value = ISOToDate(rawVal); else this.value = rawVal;
        delete this.oldValue;
    };
    WAF.EntityAttributeSimple.getRawValue = function() {
        var result = this.value;
        if (null != result && "date" == this.att.type) if (this.att.simpleDate) result = result.toSimpleDateString(); else result = result.toISO();
        return result;
    };
    WAF.EntityAttributeRelated = function(entity, rawVal, att) {
        WAF.EntityAttributeSimple.call(this, entity, rawVal, att);
        if (null != rawVal) if (null != rawVal.__deferred) {
            this.relEntity = null;
            this.dataURI = rawVal.__deferred.uri;
            this.relKey = rawVal.__deferred.__KEY;
        } else {
            var relClass = att.getRelatedClass();
            if (null == relClass) {
                this.relEntity = null;
                this.dataURI = null;
                this.relKey = null;
            } else {
                this.relEntity = new WAF.Entity(relClass, rawVal, {
                    getRefFromCache: true
                });
                this.dataURI = null;
                this.relKey = null;
            }
        } else {
            this.relEntity = null;
            this.dataURI = null;
            this.relKey = null;
        }
        this.setValue = WAF.EntityAttributeRelated.setValue;
        this.getValue = WAF.EntityAttributeRelated.getValue;
        this.load = this.getValue;
        this.setRawValue = WAF.EntityAttributeRelated.setRawValue;
        this.getRawValue = WAF.EntityAttributeRelated.getRawValue;
        this.getOldValue = WAF.EntityAttributeRelated.getOldValue;
        this.getRelatedKey = WAF.EntityAttributeRelated.getRelatedKey;
    };
    WAF.EntityAttributeRelated.getRelatedKey = function() {
        var key = null;
        if (null == this.relEntity) key = this.relKey; else key = this.relEntity.getKey();
        return key;
    };
    WAF.EntityAttributeRelated.getOldValue = function() {
        if (void 0 === this.oldValue) return this.getValue(); else return this.oldValue;
    };
    WAF.EntityAttributeRelated.getValue = function(options, userData) {
        if (null == options) return this.relEntity; else {
            var resOp = WAF.tools.handleArgs(arguments, 0);
            userData = resOp.userData;
            options = resOp.options;
            var val = this;
            var event = {
                entity: null
            };
            if (null == val.relEntity) if (null == val.dataURI && null == val.relKey) WAF.callHandler(false, null, event, options, userData); else {
                var relClass = val.att.getRelatedClass();
                if (null == relClass) WAF.callHandler(false, null, event, options, userData); else if (null != val.relKey) relClass.getEntity(val.relKey, {
                    onSuccess: function(event) {
                        val.relEntity = event.entity;
                        WAF.callHandler(false, null, event, options, userData);
                    },
                    onError: function(event) {
                        WAF.callHandler(true, event.error, event, options, userData);
                    },
                    autoExpand: options.autoExpand
                }); else relClass.getEntityByURI(val.dataURI, {
                    onSuccess: function(event) {
                        val.relEntity = event.entity;
                        WAF.callHandler(false, null, event, options, userData);
                    },
                    onError: function(event) {
                        WAF.callHandler(true, event.error, event, options, userData);
                    },
                    autoExpand: options.autoExpand
                });
            } else {
                event.entity = val.relEntity;
                WAF.callHandler(false, null, event, options, userData);
            }
        }
    };
    WAF.EntityAttributeRelated.setValue = function(relatedEntity) {
        if (void 0 === this.oldValue) this.oldValue = this.relEntity;
        this.relEntity = relatedEntity;
        this.touched = true;
        this.owner.touch();
        this.dataURI = null;
        if (null == relatedEntity) this.relKey = null; else if (relatedEntity instanceof WAF.Entity) this.relKey = relatedEntity.getKey(); else if (this.relKey !== relatedEntity) {
            this.relEntity = null;
            this.relKey = relatedEntity;
        }
    };
    WAF.EntityAttributeRelated.setRawValue = function(rawVal) {
        if (null != rawVal) if (null != rawVal.__deferred) {
            this.relEntity = null;
            this.dataURI = rawVal.__deferred.uri;
            this.relKey = rawVal.__deferred.__KEY;
        } else {
            var relClass = this.att.getRelatedClass();
            if (null == relClass) {
                this.relEntity = null;
                this.dataURI = null;
                this.relKey = null;
            } else {
                this.relEntity = new WAF.Entity(relClass, rawVal, {
                    getRefFromCache: true
                });
                this.dataURI = null;
                this.relKey = null;
            }
        } else {
            this.relEntity = null;
            this.dataURI = null;
            this.relKey = null;
        }
        delete this.oldValue;
    };
    WAF.EntityAttributeRelated.getRawValue = function() {
        var result = this.relEntity;
        if (null != result) {
            var key = result.getKey();
            if (null != key) result = {
                __KEY: key
            }; else result = result._private.getRESTFormat();
        }
        return result;
    };
    WAF.EntityAttributeRelatedSet = function(entity, rawVal, att) {
        WAF.EntityAttributeSimple.call(this, entity, rawVal, att);
        if (null != rawVal) if (null != rawVal.__deferred) {
            this.relEntityCollection = null;
            this.dataURI = rawVal.__deferred.uri;
        } else {
            var relClass = att.getRelatedClass();
            if (null == relClass) {
                this.relEntityCollection = null;
                this.dataURI = null;
            } else {
                this.relEntityCollection = new WAF.EntityCollection(relClass, null, {
                    prefetchedData: rawVal
                });
                this.dataURI = this.relEntityCollection._private.dataURI;
            }
        } else {
            this.relEntityCollection = null;
            this.dataURI = null;
        }
        this.setValue = WAF.EntityAttributeRelatedSet.setValue;
        this.getValue = WAF.EntityAttributeRelatedSet.getValue;
        this.setRawValue = WAF.EntityAttributeRelatedSet.setRawValue;
    };
    WAF.EntityAttributeRelatedSet.setRawValue = function(rawVal) {
        if (null != rawVal) if (null != this.dataURI && rawVal.__deferred == this.dataURI) ; else if (null != rawVal.__deferred) {
            this.relEntityCollection = null;
            this.dataURI = rawVal.__deferred.uri;
        } else {
            var relClass = this.att.getRelatedClass();
            if (null == relClass) {
                this.relEntityCollection = null;
                this.dataURI = null;
            } else {
                this.relEntityCollection = new WAF.EntityCollection(relClass, null, {
                    prefetchedData: rawVal
                });
                this.dataURI = this.relEntityCollection._private.dataURI;
            }
        } else {
            this.relEntityCollection = null;
            this.dataURI = null;
        }
    };
    WAF.EntityAttributeRelatedSet.getValue = function(options, userData) {
        if (null == options) return this.relEntityCollection; else {
            var resOp = WAF.tools.handleArgs(arguments, 0);
            userData = resOp.userData;
            options = resOp.options;
            var relSet = null;
            var val = this;
            var event = {
                entityCollection: null
            };
            if (null != this.relEntityCollection) {
                relSet = this.relEntityCollection;
                if (relSet._private.ready) {
                    event.entityCollection = relSet;
                    WAF.callHandler(false, null, event, options, userData);
                } else {
                    var funcToCall = function() {
                        if (relSet._private.ready) {
                            event.entityCollection = relSet;
                            WAF.callHandler(false, null, event, options, userData);
                        } else setTimeout(funcToCall, 100);
                    };
                    setTimeout(funcToCall, 100);
                }
            } else {
                var relClass = this.att.getRelatedClass();
                if (null == relClass) WAF.callHandler(true, {
                    error: 601,
                    errorMessage: "wrong entityCollection reference"
                }, event, options, userData); else {
                    if (null == this.dataURI) this.dataURI = "*";
                    options.isARelatedEntityCollection = true;
                    options.dataURI = this.dataURI;
                    this.relEntityCollection = new WAF.EntityCollection(relClass, null, options, userData);
                    relSet = this.relEntityCollection;
                }
            }
            return relSet;
        }
    };
    WAF.Entity = function(dataClass, rawData, options) {
        var entity = this;
        options = options || {};
        var tryToGetRefFromCache = (options.getRefFromCache || false) && dataClass.mustCacheRef();
        var cache;
        var cacheInfo = null;
        var key;
        if (tryToGetRefFromCache && null != rawData) {
            cache = dataClass.getRefCache();
            key = rawData.__KEY;
            if (null != key) {
                cacheInfo = cache.getCacheInfo(key);
                if (null != cacheInfo) if (rawData.__STAMP === cacheInfo.entity.getStamp()) {
                    cacheInfo.timeStamp = new Date();
                    entity = cacheInfo.entity;
                    return entity;
                }
            }
        }
        this._private = {
            touched: false,
            isNew: true,
            dataClass: dataClass,
            owner: this,
            values: {},
            methodRefs: dataClass._private.entityMethodRefs,
            methods: dataClass._private.entityMethods,
            getRESTFormat: WAF.Entity.getRESTFormat
        };
        var priv = this._private;
        var methods = priv.methods;
        for (var e in methods) entity[e] = methods[e];
        this.touch = WAF.Entity.touch;
        this.getDataClass = WAF.Entity.getDataClass;
        this.getKey = WAF.Entity.getKey;
        this.setStamp = WAF.Entity.setStamp;
        this.setKey = WAF.Entity.setKey;
        this.getStamp = WAF.Entity.getStamp;
        this.callMethod = WAF.Entity.callMethod;
        this.isNew = WAF.Entity.isNew;
        this.isTouched = WAF.Entity.isTouched;
        this.save = WAF.Entity.save;
        this.remove = WAF.Entity.remove;
        this.lock = WAF.Entity.lock;
        this.unlock = WAF.Entity.unlock;
        this._dolock = WAF.Entity._dolock;
        this.serverRefresh = WAF.Entity.serverRefresh;
        var isnew = false;
        if (null == rawData || null == rawData.__KEY) {
            this._private.key = null;
            this._private.stamp = 0;
            this._private.isNew = true;
            isnew = true;
            if (null != rawData) this._private.touched = true;
        } else {
            this._private.key = rawData.__KEY;
            this._private.stamp = rawData.__STAMP;
            this._private.isNew = false;
        }
        var values = entity._private.values;
        var attsByName = dataClass._private.attributesByName;
        for (var e in attsByName) {
            var att = attsByName[e];
            var val = null == rawData ? null : null == rawData[e] ? null : rawData[e];
            var valAtt;
            if (!att.related) valAtt = new WAF.EntityAttributeSimple(entity, val, att); else if (att.relatedOne) valAtt = new WAF.EntityAttributeRelated(entity, val, att); else valAtt = new WAF.EntityAttributeRelatedSet(entity, val, att);
            if (isnew && null != val) valAtt.touched = true;
            values[e] = valAtt;
            entity[e] = valAtt;
        }
        if (tryToGetRefFromCache && null != rawData) {
            cache.setEntry(entity);
            if (null != cacheInfo) return cacheInfo.entity;
        }
    };
    WAF.Entity.getRESTFormat = function(overrideStamp) {
        var priv = this;
        var entity = this.owner;
        var result = {};
        var key = entity.getKey();
        if (null != key) {
            result.__KEY = key;
            result.__STAMP = entity.getStamp();
            if (overrideStamp) result.__STAMP = -result.__STAMP;
        } else result.__ISNEW = true;
        for (var e in priv.values) {
            var valAtt = priv.values[e];
            if (valAtt.isTouched()) result[e] = valAtt.getRawValue();
        }
        return result;
    };
    WAF.Entity.touch = function() {
        this._private.touched = true;
    };
    WAF.Entity.getDataClass = function() {
        return this._private.dataClass;
    };
    WAF.Entity.getKey = function() {
        return this._private.key;
    };
    WAF.Entity.getStamp = function() {
        return this._private.stamp;
    };
    WAF.Entity.setKey = function(key) {
        this._private.key = key;
    };
    WAF.Entity.setStamp = function(stamp) {
        this._private.stamp = stamp;
    };
    WAF.Entity.callMethod = function(options) {
        var entity = this;
        var methodRef = entity._private.methodRefs[options.method];
        if (null != methodRef) {
            var myargs = [];
            if (null != options.arguments) myargs = options.arguments; else for (var i = 1, nb = arguments.length; i < nb; i++) myargs.push(arguments[i]);
            return WAF.DataStore.funcCaller(methodRef, entity, myargs, options);
        }
    };
    WAF.Entity.isNew = function() {
        return this._private.isNew;
    };
    WAF.Entity.isTouched = function() {
        return this._private.touched;
    };
    WAF.Entity.serverRefresh = function(options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        options.refreshOnly = true;
        this.save(options, userData);
    };
    WAF.Entity.lock = function(options, userdata) {
        this._dolock(true, options || null, userdata || null);
    };
    WAF.Entity.unlock = function(options, userdata) {
        this._dolock(false, options || null, userdata || null);
    };
    WAF.Entity._dolock = function(mustlock, options, userdata) {
        var entity = this;
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = entity.getDataClass();
        var dataClassName = dataClass.getName();
        var key = entity.getKey();
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = dataClassName + "(" + key + ")";
        request.mustlock = mustlock;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var lockresult = false;
            var error = false;
            var err = null;
            var result = WAF.getRequestResult(request);
            if (null != result.__ERROR) {
                error = true;
                err = result.__ERROR;
            } else lockresult = result.result;
            var event = {
                entity: entity,
                result: lockresult
            };
            WAF.callHandler(error, err, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.Entity.remove = function(options, userData) {
        var entity = this;
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = entity.getDataClass();
        var dataClassName = dataClass.getName();
        var key = entity.getKey();
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = dataClassName + "(" + key + ")";
        request.method = "delete";
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var error = false;
            var err = null;
            var result = WAF.getRequestResult(request);
            if (null != result.__ERROR) {
                error = true;
                err = result.__ERROR;
            } else dataClass.getCache().removeCachedEntity(key);
            var event = {
                entity: entity
            };
            WAF.callHandler(error, err, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.Entity.save = function(options, userData) {
        var entity = this;
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = entity.getDataClass();
        var dataClassName = dataClass.getName();
        var refreshOnly = options.refreshOnly;
        if (null == refreshOnly) refreshOnly = false;
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = dataClassName;
        var key = entity.getKey();
        if (null == key) {
            request.method = "update";
            request.httpMethod = WAF.core.restConnect.httpMethods._post;
        } else {
            request.method = "update";
            request.httpMethod = WAF.core.restConnect.httpMethods._post;
        }
        request.postdata = '{ "__ENTITIES": [' + JSON.stringify(entity._private.getRESTFormat(options.overrideStamp)) + "]}";
        request.refreshOnly = refreshOnly;
        if (null != options.autoExpand) request.autoExpand = options.autoExpand;
        if (null != options.filterAttributes) request.filterAttributes = options.filterAttributes;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entity: entity,
                rawResult: rawResult,
                XHR: request.http_request
            };
            var rawResult = JSON.parse(request.http_request.responseText);
            var withError = false;
            var err = null;
            if (rawResult) if (rawResult.__ENTITIES) if (rawResult.__ENTITIES[0]) {
                var rawResultRec = rawResult.__ENTITIES[0];
                if (rawResultRec.__ERROR) {
                    err = rawResultRec.__ERROR;
                    withError = true;
                } else {
                    var oldKEY = key;
                    var newKEY = rawResultRec.__KEY;
                    if (!refreshOnly) {
                        if (null != newKEY) entity._private.key = newKEY;
                        entity._private.stamp = rawResultRec.__STAMP;
                    }
                    var attsByName = dataClass._private.attributesByName;
                    for (var e in attsByName) {
                        var att = attsByName[e];
                        var val = rawResultRec[e];
                        if (void 0 === val) val = null;
                        var valAtt = entity[e];
                        if (null == valAtt) {
                            if (!att.related) valAtt = new WAF.EntityAttributeSimple(entity, val, att); else if (att.relatedOne) valAtt = new WAF.EntityAttributeRelated(entity, val, att); else valAtt = new WAF.EntityAttributeRelatedSet(entity, val, att);
                            entity[e] = valAtt;
                        } else {
                            if (true || valAtt.isTouched()) valAtt.setRawValue(val);
                            if (!refreshOnly) valAtt.clearTouched();
                        }
                    }
                    if (dataClass.mustCacheRef()) dataClass.getRefCache().setEntry(entity); else dataClass.getCache().replaceCachedEntity(newKEY, rawResultRec);
                    if (!refreshOnly) {
                        entity._private.touched = false;
                        entity._private.isNew = false;
                    }
                }
            }
            WAF.callHandler(withError, err, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.prototype.getDataClass = WAF.EntityCollection.getDataClass;
    WAF.EntityCollection.prototype.query = WAF.EntityCollection.query;
    WAF.EntityCollection.prototype.getEntity = WAF.EntityCollection.getEntity;
    WAF.EntityCollection.prototype.getEntities = WAF.EntityCollection.getEntities;
    WAF.EntityCollection.prototype.callMethod = WAF.EntityCollection.callMethod;
    WAF.EntityCollection.prototype.each = WAF.EntityCollection.forEach;
    WAF.EntityCollection.prototype.forEach = WAF.EntityCollection.forEach;
    WAF.EntityCollection.prototype.forEachInCache = WAF.EntityCollection.forEachInCache;
    WAF.EntityCollection.prototype.add = WAF.EntityCollection.add;
    WAF.EntityCollection.prototype.orderBy = WAF.EntityCollection.orderBy;
    WAF.EntityCollection.prototype.toArray = WAF.EntityCollection.toArray;
    WAF.EntityCollection.prototype.distinctValues = WAF.EntityCollection.distinctValues;
    WAF.EntityCollection.prototype.findKey = WAF.EntityCollection.findKey;
    WAF.EntityCollection.prototype.removeEntity = WAF.EntityCollection.removeEntity;
    WAF.EntityCollection.prototype.removeEntityReference = WAF.EntityCollection.removeEntityReference;
    WAF.EntityCollection.prototype.removeAllEntities = WAF.EntityCollection.removeAllEntities;
    WAF.EntityCollection.prototype.buildFromSelection = WAF.EntityCollection.buildFromSelection;
    WAF.EntityCollection.prototype.getReference = WAF.EntityCollection.getReference;
    WAF.EntityCollection.prototype.refresh = WAF.EntityCollection.refresh;
    WAF.DataClass.prototype.distinctValues = WAF.DataClass.distinctValues;
    WAF.DataClass.prototype.all = WAF.DataClass.allEntities;
    WAF.DataClass.prototype.allEntities = WAF.DataClass.allEntities;
    WAF.DataClass.prototype.query = WAF.DataClass.query;
    WAF.DataClass.prototype.find = WAF.DataClass.find;
    WAF.DataClass.prototype.getAttributeByName = WAF.DataClass.getAttributeByName;
    WAF.DataClass.prototype.getAttributes = WAF.DataClass.getAttributes;
    WAF.DataClass.prototype.getMethodList = WAF.DataClass.getMethodList;
    WAF.DataClass.prototype.getCache = WAF.DataClass.getCache;
    WAF.DataClass.prototype.getRefCache = WAF.DataClass.getRefCache;
    WAF.DataClass.prototype.getCacheSize = WAF.DataClass.getCacheSize;
    WAF.DataClass.prototype.setCacheSize = WAF.DataClass.setCacheSize;
    WAF.DataClass.prototype.clearCache = WAF.DataClass.clearCache;
    WAF.DataClass.prototype.newEntity = WAF.DataClass.newEntity;
    WAF.DataClass.prototype.getEntity = WAF.DataClass.getEntity;
    WAF.DataClass.prototype.getEntityByURI = WAF.DataClass.getEntityByURI;
    WAF.DataClass.prototype.getDataStore = WAF.DataClass.getDataStore;
    WAF.DataClass.prototype.getCollectionName = WAF.DataClass.getCollectionName;
    WAF.DataClass.prototype.getDefaultTopSize = WAF.DataClass.getDefaultTopSize;
    WAF.DataClass.prototype.getName = WAF.DataClass.getName;
    WAF.DataClass.prototype.newCollection = WAF.DataClass.newCollection;
    WAF.DataClass.prototype.toArray = WAF.DataClass.toArray;
    WAF.DataClass.prototype.mustCacheRef = WAF.DataClass.mustCacheRef;
    WAF.DataClass.prototype.callMethod = WAF.DataStore.callMethod;
    WAF.directory = WAF.directory || {};
    WAF.directory.login = WAF.DataStore.makeFuncCaller({
        name: "login",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.directory.loginByPassword = WAF.directory.login;
    WAF.directory.logout = WAF.DataStore.makeFuncCaller({
        name: "logout",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.directory.loginByKey = WAF.DataStore.makeFuncCaller({
        name: "loginByKey",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.directory.currentUser = WAF.DataStore.makeFuncCaller({
        name: "currentUser",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.directory.currentUserBelongsTo = WAF.DataStore.makeFuncCaller({
        name: "currentUserBelongsTo",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.dsExport = WAF.dsExport || {};
    WAF.dsExport.exportData = WAF.DataStore.makeFuncCaller({
        name: "exportData",
        applyTo: "general",
        nameSpace: "$impexp"
    });
    var wakanda = angular.module("wakanda", []);
    wakanda.factory("$wakanda", [ "$q", "$rootScope", "$http", function($q, $rootScope, $http) {
        var ds = null, NgWakEntityClasses = {}, DEFAULT_PAGESIZE_NESTED_COLLECTIONS = 40, DEFAULT_CACHE_SIZE = 300, DEFAULT_CACHE_DEEP = 3;
        var init = function(catalog) {
            console.log(">$wakanda init");
            var deferred = $q.defer();
            if ("string" !== typeof catalog || "*" === catalog || "" === catalog) catalog = null;
            if (null === ds) new WAF.DataStore({
                onSuccess: function(event) {
                    ds = event.dataStore;
                    prepare.wafDatastore(ds);
                    prepare.wafDataClasses(ds);
                    deferred.resolve(ds);
                },
                onError: function(event) {
                    ds = null;
                    console.error(">$wakanda init > error", event);
                    deferred.reject(event);
                },
                catalog: catalog
            }); else deferred.resolve(ds);
            return deferred.promise;
        };
        var getDatastore = function() {
            if (null !== ds) return ds; else throw new Error("The Datastore isn't initialized please execute .init(catalog) before you run your app.");
        };
        var rootScopeSafeApply = function(fn) {
            var phase = $rootScope.$$phase;
            if ("$apply" === phase || "$digest" === phase) {
                if (fn && "function" === typeof fn) fn();
            } else $rootScope.$apply(fn);
        };
        var helpers = {
            shallowClearAndCopy: function(src, dst) {
                dst = dst || {};
                angular.forEach(dst, function(value, key) {
                    delete dst[key];
                });
                for (var key in src) if (src.hasOwnProperty(key)) dst[key] = src[key];
                return dst;
            }
        };
        var prepare = {
            wafDatastore: function(dataStore) {
                dataStore.$Entity = NgWakEntityAbstract.prototype;
            },
            wafDataClasses: function(dataStore) {
                var dataClassName;
                WAF.DataClass.prototype.$find = $$find;
                WAF.DataClass.prototype.$findOne = $$findOne;
                WAF.DataClass.prototype.$create = $$create;
                for (dataClassName in dataStore) if (dataStore.hasOwnProperty(dataClassName) && "_private" !== dataClassName && false === /^\$.*/.test(dataClassName)) {
                    prepare.wafDataClassAddMetas(dataStore[dataClassName]);
                    prepare.wafDataClassAddDataClassMethods(dataStore[dataClassName]);
                    prepare.wafDataClassCreateNgWakEntityClasses(dataStore[dataClassName]);
                    prepare.wafDataClassCreateRefCache(dataStore[dataClassName]);
                }
            },
            wafDataClassAddMetas: function(dataClass) {
                var methodInfo, dataClassMethods = [], collectionMethods = [], entityMethods = [], attributes, attributeName;
                angular.forEach(dataClass.getMethodList(), function(methodInfo) {
                    switch (methodInfo.applyTo) {
                      case "entity":
                        entityMethods.push(methodInfo.name);
                        break;

                      case "entityCollection":
                        collectionMethods.push(methodInfo.name);
                        break;

                      case "dataClass":
                        dataClassMethods.push(methodInfo.name);
                    }
                });
                attributes = dataClass._private.attributesByName;
                dataClass.$attr = function(attrName) {
                    if ("undefined" === typeof attrName) return attributes; else if (attrName && attributes[attrName]) return attributes[attrName]; else return null;
                };
                dataClass.$dataClassMethods = function() {
                    return dataClassMethods;
                };
                dataClass.$collectionMethods = function() {
                    return collectionMethods;
                };
                dataClass.$entityMethods = function() {
                    return entityMethods;
                };
                dataClass.$name = dataClass.getName();
                dataClass.$collectionName = dataClass.getCollectionName();
                for (attributeName in attributes) if (true === attributes[attributeName].identifying) dataClass.$_identifyingAttr = attributes[attributeName];
            },
            wafDataClassAddDataClassMethods: function(dataClass) {
                prepareHelpers.createUserDefinedDataClassMethods(dataClass);
            },
            wafDataClassCreateNgWakEntityClasses: function(dataClass) {
                var proto;
                proto = prepareHelpers.createUserDefinedEntityMethods(dataClass);
                NgWakEntityClasses[dataClass.getName()] = NgWakEntityAbstract.extend(proto);
                ds[dataClass.getName()].$Entity = NgWakEntityClasses[dataClass.getName()].prototype;
            },
            wafDataClassCreateRefCache: function(dataClass) {
                dataClass.$refCache = new NgWakEntityCache();
            }
        };
        var prepareHelpers = {
            createUserDefinedEntityMethods: function(dataClass) {
                var methodName, proto = {};
                for (methodName in dataClass._private.entityMethods) if (dataClass._private.entityMethods.hasOwnProperty(methodName)) {
                    proto[methodName + "Sync"] = function() {
                        return this.$_entity[methodName].apply(this.$_entity, arguments);
                    };
                    prepareHelpers.wakandaUserDefinedMethodToPromisableMethods(proto, methodName, dataClass._private.entityMethods[methodName]);
                }
                return proto;
            },
            createUserDefinedEntityCollectionMethods: function(dataClass) {
                var methodName, proto = {};
                for (methodName in dataClass._private.entityCollectionMethods) if (dataClass._private.entityCollectionMethods.hasOwnProperty(methodName)) {
                    proto[methodName + "Sync"] = function() {
                        return this.$_collection[methodName].apply(this.$_collection, arguments);
                    };
                    prepareHelpers.wakandaUserDefinedMethodToPromisableMethods(proto, methodName, dataClass._private.entityCollectionMethods[methodName]);
                }
                return proto;
            },
            createUserDefinedDataClassMethods: function(dataClass) {
                angular.forEach(dataClass.$dataClassMethods(), function(methodName) {
                    dataClass[methodName] = function() {
                        var defer = $q.defer();
                        dataClass.callMethod({
                            method: methodName,
                            onSuccess: function(event) {
                                defer.resolve(event);
                            },
                            onError: function(error) {
                                console.error("userDataClassMethods.onError", "error", error);
                                defer.reject(error);
                            },
                            arguments: arguments.length > 0 ? Array.prototype.slice.call(arguments, 0) : []
                        });
                        return defer.promise;
                    };
                    dataClass[methodName + "Sync"] = function() {
                        return dataClass.callMethod({
                            method: methodName,
                            sync: true,
                            arguments: arguments.length > 0 ? Array.prototype.slice.call(arguments, 0) : []
                        });
                    };
                });
            },
            wakandaUserDefinedMethodToPromisableMethods: function(proto, methodName, method) {
                proto[methodName] = function() {
                    var thatArguments = [], that, wakOptions = {}, mode, deferred;
                    if (this instanceof NgWakEntityAbstract) {
                        if ("undefined" === typeof this.$_entity || !this.$_entity instanceof WAF.Entity) throw new Error("Calling user defined method on unfetched entity, please call $fetch before or retrieve data on $find");
                        mode = "$_entity";
                    } else mode = "$_collection";
                    if (arguments.length > 0) for (var i = 0; i < arguments.length; i++) thatArguments.push(arguments[i]);
                    if ("$_entity" === mode) this.$syncPojoToEntity(); else ;
                    deferred = $q.defer();
                    var that = this;
                    wakOptions.onSuccess = function(event) {
                        rootScopeSafeApply(function() {
                            if ("$_entity" === mode) that.$syncEntityToPojo(); else ;
                            deferred.resolve(event);
                        });
                    };
                    wakOptions.onError = function(error) {
                        rootScopeSafeApply(function() {
                            console.error("userMethods.onError", "error", error);
                            deferred.reject(error);
                        });
                    };
                    thatArguments.unshift(wakOptions);
                    if ("$_entity" === mode) method.apply(this[mode], thatArguments); else {
                        if (!this.$_collection) throw new Error("Couldn't call user defined method on collection because no pointer on this collection");
                        method.apply(this[mode], thatArguments);
                    }
                    return deferred.promise;
                };
            }
        };
        var collectionToNgWakEntityCollection = window.collectionToNgWakEntityCollection = function(wafEntityCollection, options) {
            options = "undefined" === typeof options ? {} : options;
            var result = "undefined" === typeof options.result ? [] : options.result;
            var start = "undefined" === typeof options.start ? 0 : options.start;
            var pageSize = "undefined" === typeof options.pageSize ? DEFAULT_PAGESIZE_NESTED_COLLECTIONS : options.pageSize;
            var currentDataClass = wafEntityCollection.getDataClass();
            wafEntityCollection.forEachInCache({
                onSuccess: function(item) {
                    console.log(item);
                },
                first: start,
                limit: start + pageSize
            });
            var reccursiveCollectionToNgWakEntityCollection = function(wafEntityCollection) {};
        };
        var entityToNgWakEntity = function(wafEntity) {
            var currentDataClass = wafEntity.getDataClass();
            var attributes = currentDataClass.$attr();
            var wakEntity = new NgWakEntityClasses[currentDataClass.$name]();
        };
        var transform = {
            queryEventToNgWakEntityCollection: function(event, onlyOne) {
                var rawEntities, parsedXhrResponse, result;
                parsedXhrResponse = JSON.parse(event.XHR.response);
                rawEntities = parsedXhrResponse.__ENTITIES;
                result = transform.jsonResponseToNgWakEntityCollection(event.result.getDataClass(), rawEntities);
                if (true !== onlyOne) result.$_collection = event.result; else if (1 === result.length) result = result[0]; else result = null;
                event.result = result;
                return event;
            },
            jsonResponseToNgWakEntityCollection: function(dataClass, xhrResponse) {
                var ngWakEntityCollection = [];
                xhrResponse.map(function(pojo) {
                    ngWakEntityCollection.push(dataClass.$create(pojo));
                });
                return ngWakEntityCollection;
            },
            fetchEventToNgWakEntityCollection: function(event) {
                var result = [], dataClass = event.result._private.dataClass;
                event.entities.forEach(function(entity, index) {
                    result.push(dataClass.$create(entity));
                });
                event.result = result;
            },
            asyncResult: function(data, result, promise) {
                var userDefinedEntityCollectionMethods;
                if (data instanceof Array) {
                    result.length = 0;
                    angular.forEach(data, function(item) {
                        result.push(item);
                    });
                    result.$_collection = data.$_collection;
                    transform.addFrameworkMethodsToRootCollection(result);
                    transform.addUserDefinedMethodsToCollection(result, true);
                    result.$promise = promise;
                } else {
                    if ("undefined" === typeof result.$_entity && "undefined" !== typeof data.$_entity) result.$_entity = data.$_entity;
                    helpers.shallowClearAndCopy(data, result);
                    result.$promise = promise;
                }
            },
            addUserDefinedMethodsToCollection: function(result, root) {
                var userDefinedEntityCollectionMethods, dataClass = null;
                if (true === root) {
                    if ("undefined" !== typeof result.$_collection) dataClass = result.$_collection.getDataClass();
                } else if (false === root) if ("undefined" !== typeof result.$_collection && "undefined" !== result.$_collection.relEntityCollection) dataClass = result.$_collection.relEntityCollection;
                if (null === dataClass) return result;
                userDefinedEntityCollectionMethods = prepareHelpers.createUserDefinedEntityCollectionMethods(dataClass);
                for (var methodName in userDefinedEntityCollectionMethods) if (userDefinedEntityCollectionMethods.hasOwnProperty(methodName)) result[methodName] = userDefinedEntityCollectionMethods[methodName];
                return result;
            },
            addFrameworkMethodsToRootCollection: function(result) {
                result.$fetch = $$fetch;
                result.$add = $$add;
                result.$more = $$more;
                result.$nextPage = $$nextPage;
                result.$prevPage = $$prevPage;
                result.$totalCount = result.$_collection.length;
                result.$toJSON = $$toJSON;
            },
            addFrameworkMethodsToNestedCollection: function(result) {
                result.$fetch = $fetchOnNestedCollection;
                result.$more = $$more;
                result.$nextPage = $$nextPage;
                result.$prevPage = $$prevPage;
                result.$toJSON = $$toJSON;
                result.$isLoaded = $$isLoadedOnNestedCollection;
                result.$totalCount = null;
            }
        };
        var $$create = function(pojo) {
            var dataClassName = this.getName(), ngWakEntity;
            pojo = "undefined" === typeof pojo ? {} : pojo;
            ngWakEntity = new NgWakEntityClasses[dataClassName]();
            reccursiveFillNgWakEntityFromEntity(pojo, ngWakEntity, this);
            return ngWakEntity;
        };
        var reccursiveFillNgWakEntityFromEntity = function(entity, ngWakEntityNestedObject, currentDataClass) {
            var key, defferedKey, attributes = currentDataClass.$attr(), isEntityWafEntity = entity instanceof WAF.Entity, tmpDeferredInfos, imageDeferredAttributesMapping = {
                uri: "src"
            };
            if (null === entity || "undefined" === typeof entity) return; else if (false === isEntityWafEntity) if (entity.__deferred) ngWakEntityNestedObject.$_deferred = {
                uri: entity.__deferred.uri,
                dataClass: currentDataClass
            }; else if (entity.value && entity.value.__deferred) ngWakEntityNestedObject.$_deferred = {
                uri: entity.value.__deferred.uri,
                dataClass: currentDataClass
            }; else ngWakEntityNestedObject.$_entity = new WAF.Entity(currentDataClass, entity); else ngWakEntityNestedObject.$_entity = entity;
            if (isEntityWafEntity) {
                ngWakEntityNestedObject.__KEY = entity.getKey();
                ngWakEntityNestedObject.__STAMP = entity.getStamp();
            } else {
                if ("undefined" !== typeof entity.__KEY) ngWakEntityNestedObject.__KEY = entity.__KEY;
                if ("undefined" !== typeof entity.__STAMP) ngWakEntityNestedObject.__STAMP = entity.__STAMP;
            }
            for (key in attributes) if ("undefined" !== typeof entity[key]) if ("storage" === attributes[key].kind || "calculated" === attributes[key].kind || "alias" === attributes[key].kind) {
                if ("image" === attributes[key].type) {
                    ngWakEntityNestedObject[key] = {};
                    tmpDeferredInfos = isEntityWafEntity ? entity[key].getValue() : entity[key];
                    if (tmpDeferredInfos && tmpDeferredInfos.__deferred) for (defferedKey in tmpDeferredInfos.__deferred) ngWakEntityNestedObject[key][imageDeferredAttributesMapping[defferedKey] ? imageDeferredAttributesMapping[defferedKey] : defferedKey] = tmpDeferredInfos.__deferred[defferedKey]; else ngWakEntityNestedObject[key][imageDeferredAttributesMapping["uri"]] = null;
                    ngWakEntityNestedObject[key].$upload = $$upload;
                } else if (isEntityWafEntity) ngWakEntityNestedObject[key] = entity[key].getValue(); else if ("undefined" !== typeof entity[key]) {
                    ngWakEntityNestedObject[key] = isEntityWafEntity ? entity[key].getValue() : entity[key];
                    if ("date" === attributes[key].type && null !== ngWakEntityNestedObject[key] && ngWakEntityNestedObject[key] instanceof Date === false) ngWakEntityNestedObject[key] = new Date(ngWakEntityNestedObject[key]);
                }
            } else if ("relatedEntities" === attributes[key].kind) {
                if (entity[key].__ENTITIES) {
                    ngWakEntityNestedObject[key] = transform.jsonResponseToNgWakEntityCollection(attributes[key].getRelatedClass(), entity[key].__ENTITIES);
                    transform.addFrameworkMethodsToNestedCollection(ngWakEntityNestedObject[key]);
                } else if (entity[key].__deferred) {
                    ngWakEntityNestedObject[key] = [];
                    ngWakEntityNestedObject[key].$_deferred = {
                        uri: entity[key].__deferred.uri,
                        dataClass: attributes[key].getRelatedClass(),
                        attr: key
                    };
                    transform.addFrameworkMethodsToNestedCollection(ngWakEntityNestedObject[key]);
                }
                if (ngWakEntityNestedObject[key]) ngWakEntityNestedObject[key].$_collection = ngWakEntityNestedObject.$_entity[key];
            } else if ("relatedEntity" === attributes[key].kind) {
                ngWakEntityNestedObject[key] = new (NgWakEntityClasses[isEntityWafEntity && entity[key].relEntity ? entity[key].relEntity.getDataClass().$name : ds[currentDataClass.$name].$attr(key).type])();
                if (isEntityWafEntity && null !== entity[key].relEntity) reccursiveFillNgWakEntityFromEntity(entity[key].relEntity, ngWakEntityNestedObject[key], entity[key].relEntity.getDataClass()); else reccursiveFillNgWakEntityFromEntity(entity[key], ngWakEntityNestedObject[key], ds[ds[currentDataClass.$name].$attr(key).type]);
            }
        };
        var $$upload = function(file) {
            console.log("$upload not yet implemented");
        };
        var updateCollectionQueryInfos = function(resultSet, pageSize, start) {
            if ("undefined" === typeof resultSet.$query) resultSet.$query = {};
            resultSet.$query.pageSize = pageSize;
            resultSet.$query.start = start;
        };
        var $fetchOnNestedCollection = function(options, mode) {
            console.warn("This method is currently under refactoring");
            var that = this, deferred = $q.defer(), wakOptions = {};
            mode = "undefined" === typeof mode || "replace" === mode ? "replace" : mode;
            if (!that.$_collection) {
                deferred.reject("Missing $_collection private pointer (WAF.EntityAttributeRelatedSet), check if you used $find or $fetch to load the collection");
                console.warn("Missing $_collection private pointer (WAF.EntityAttributeRelatedSet), check if you used $find or $fetch to load the collection");
            } else {
                if (!options) options = {};
                if ("undefined" !== typeof options.orderBy) console.warn("orderBy can't be change on a $fetch (nested query collection's cached on server side in some way)");
                if ("undefined" !== typeof options.select) console.warn("select can't be change on a $fetch (query collection's cached on server side in some way)");
                wakOptions.skip = options.start = "undefined" === typeof options.start ? this.$query ? this.$query.start : 0 : options.start;
                wakOptions.top = options.pageSize = "undefined" === typeof options.pageSize ? this.$query ? this.$query.pageSize : DEFAULT_PAGESIZE_NESTED_COLLECTIONS : options.pageSize;
                if (options.select) wakOptions.autoExpand = options.select;
                if (options.orderBy) wakOptions.orderby = options.orderBy;
                rootScopeSafeApply(function() {
                    that.$fetching = true;
                });
                console.log(">$fetch on nestedCollection", "options", options);
                wakOptions.onSuccess = function(e) {
                    console.log("$fetchOnNestedCollection > onSuccess", "e", e);
                    rootScopeSafeApply(function() {
                        if ("replace" === mode) that.length = 0;
                        e.entityCollection.forEach({
                            onSuccess: function(item) {
                                rootScopeSafeApply(function() {
                                    console.log(item.position, item.entity, that.$_collection.relEntityCollection.getDataClass());
                                    that.push(that.$_collection.relEntityCollection.getDataClass().$create(item.entity));
                                });
                            },
                            atTheEnd: function(e) {
                                console.log("atTheEnd", "e", e);
                            },
                            first: wakOptions.skip,
                            limit: wakOptions.skip + wakOptions.top
                        });
                        delete that.$_deferred;
                        updateCollectionQueryInfos(that, options.pageSize, options.start);
                        that.$totalCount = e.entityCollection.length;
                        that.$fetching = false;
                        deferred.resolve(that);
                    });
                };
                wakOptions.onError = function(event) {
                    rootScopeSafeApply(function() {
                        console.error("$fetch (nestedEntities) ) > onError", event);
                        that.$fetching = false;
                        deferred.reject(event);
                    });
                };
                console.log("wakOptions", wakOptions);
                that.$_collection.getValue(wakOptions);
            }
            return deferred.promise;
        };
        $$isLoadedOnNestedCollection = function() {
            if (this.$_deferred) return false; else return true;
        };
        var updateQueryInfos = function(resultSet, pageSize, start, filter) {
            if ("undefined" === typeof resultSet.$query) resultSet.$query = {};
            resultSet.$query.pageSize = pageSize;
            resultSet.$query.start = start;
            resultSet.$query.filter = filter ? filter : resultSet.$query.filter;
        };
        var $$fetch = function(options, mode) {
            var deferred, wakOptions = {}, that = this, skip, top;
            mode = "undefined" === typeof mode || "replace" === mode ? "replace" : mode;
            if (!options) options = {};
            if ("undefined" !== typeof options.orderBy) throw new Error("orderBy can't be change on a $fetch (query collection's cached on server side)");
            if ("undefined" !== typeof options.select) throw new Error("select can't be change on a $fetch (query collection's cached on server side)");
            skip = options.start = "undefined" === typeof options.start ? this.$query.start : options.start;
            top = options.pageSize = options.pageSize || this.$query.pageSize;
            if (options.params) wakOptions.params = options.params;
            deferred = $q.defer();
            var that = this;
            rootScopeSafeApply(function() {
                that.$fetching = true;
            });
            wakOptions.onSuccess = function(event) {
                rootScopeSafeApply(function() {
                    transform.fetchEventToNgWakEntityCollection(event);
                    if ("replace" === mode) {
                        that.length = 0;
                        for (var i = 0; i < event.result.length; i++) that[i] = event.result[i];
                    } else if ("append" === mode) for (var i = 0; i < event.result.length; i++) that.push(event.result[i]);
                    updateQueryInfos(that, options.pageSize || that.$_collection._private.pageSize, skip);
                    that.$fetching = false;
                    deferred.resolve(event);
                });
            };
            wakOptions.onError = function(event) {
                rootScopeSafeApply(function() {
                    console.error("$fetch > getEntities > onError", event);
                    that.$fetching = false;
                    deferred.reject(event);
                });
            };
            this.$_collection.getEntities(skip, top, wakOptions);
            return deferred.promise;
        };
        $$toJSON = function() {
            var getCleanObject = function(obj) {
                var tmp, key, i;
                if (obj instanceof Array) {
                    tmp = [];
                    if (obj.length > 0) for (i = 0; i < obj.length; i++) tmp.push(getCleanObject(obj[i]));
                } else {
                    tmp = {};
                    for (key in obj) if (obj.hasOwnProperty(key) && "$_entity" !== key && "$_deferred" !== key) if (obj[key] instanceof Array || obj[key] instanceof NgWakEntityAbstract) tmp[key] = getCleanObject(obj[key]); else if (null !== obj[key] && "undefined" !== typeof obj[key] && !obj[key].$_deferred) tmp[key] = obj[key];
                }
                return tmp;
            };
            var cleanObject = getCleanObject(this);
            return JSON.stringify(cleanObject);
        };
        var $$more = function() {
            var start, pageSize, totalCount, deferred;
            if ("undefined" !== typeof this.$query) {
                start = this.$query.start + this.$query.pageSize;
                pageSize = this.$query.pageSize;
                totalCount = this.$totalCount;
            } else {
                start = 0;
                pageSize = DEFAULT_PAGESIZE_NESTED_COLLECTIONS;
                totalCount = DEFAULT_PAGESIZE_NESTED_COLLECTIONS;
            }
            if (start >= totalCount) {
                deferred = new $q.defer();
                deferred.resolve({
                    noMore: true
                });
                return deferred.promise;
            } else return this.$fetch({
                start: start,
                pageSize: pageSize
            }, "append");
        };
        var $$nextPage = function() {
            var start, pageSize, totalCount, deferred;
            if ("undefined" !== typeof this.$query) {
                start = this.$query.start + this.$query.pageSize;
                pageSize = this.$query.pageSize;
                totalCount = this.$totalCount;
            } else {
                start = 0;
                pageSize = DEFAULT_PAGESIZE_NESTED_COLLECTIONS;
                totalCount = DEFAULT_PAGESIZE_NESTED_COLLECTIONS;
            }
            if (start >= totalCount) {
                deferred = new $q.defer();
                deferred.resolve({
                    noMore: true
                });
                return deferred.promise;
            } else return this.$fetch({
                start: start,
                pageSize: pageSize
            });
        };
        var $$prevPage = function() {
            var start, pageSize, deferred, noMore;
            if ("undefined" !== typeof this.$query) {
                start = this.$query.start - this.$query.pageSize;
                pageSize = this.$query.pageSize;
            } else {
                deferred = new $q.defer();
                deferred.reject(new Error("No collection fetched to $prevPage() on."));
                console.error("No collection fetched to $prevPage() on.");
                return deferred.promise;
            }
            if (start < 0) {
                noMore = true;
                start = 0;
            }
            return this.$fetch({
                start: start,
                pageSize: pageSize
            }).then(function(e) {
                if (true === noMore) e.noMore = true;
                return e;
            });
        };
        var $$add = function() {
            console.log("$add method not yet implemented");
        };
        var $$find = function(options) {
            var deferred, wakOptions = {}, query = null, onlyOne, result;
            if (!options || "object" !== typeof options) options = {};
            if (options.select) wakOptions.autoExpand = options.select;
            if (options.filter) query = options.filter;
            if (options.params) wakOptions.params = options.params;
            if (options.orderBy) wakOptions.orderby = options.orderBy;
            if ("undefined" !== typeof options.pageSize) wakOptions.pageSize = options.pageSize;
            onlyOne = !!options.onlyOne;
            if (onlyOne) result = new NgWakEntityClasses[this.$name](); else result = [];
            deferred = $q.defer();
            result.$promise = deferred.promise;
            rootScopeSafeApply(function() {
                result.$fetching = true;
            });
            wakOptions.onSuccess = function(event) {
                rootScopeSafeApply(function() {
                    transform.queryEventToNgWakEntityCollection(event, onlyOne);
                    transform.asyncResult(event.result, result, deferred.promise);
                    if (false === onlyOne) updateQueryInfos(result, result.$_collection._private.pageSize, 0, query);
                    result.$fetching = false;
                    event.result = result;
                    deferred.resolve(event);
                });
            };
            wakOptions.onError = function(event) {
                rootScopeSafeApply(function() {
                    console.error("$find > query > onError", event);
                    result.$fetching = false;
                    deferred.reject(event);
                });
            };
            options = null;
            this.query(query, wakOptions);
            return result;
        };
        var $$findOne = function(id, options) {
            options = "undefined" === typeof options ? {} : options;
            options.filter = this.$_identifyingAttr.name + " = " + id;
            options.onlyOne = true;
            return this.$find(options);
        };
        var NgWakEntityAbstractPrototype = {
            init: function() {
                Object.defineProperty(this, "$_entity", {
                    enumerable: false,
                    configurable: false,
                    writable: true
                });
            },
            $save: function() {
                console.group("$save");
                var deferred, wakOptions = {}, that = this;
                this.$syncPojoToEntity();
                deferred = $q.defer();
                wakOptions.onSuccess = function(event) {
                    rootScopeSafeApply(function() {
                        console.log("save.onSuccess", "event", event);
                        that.$syncEntityToPojo();
                        deferred.resolve(event);
                    });
                };
                wakOptions.onError = function(error) {
                    rootScopeSafeApply(function() {
                        console.error("save.onError", "error", error);
                        deferred.reject(error);
                    });
                };
                this.$_entity.save(wakOptions);
                console.groupEnd();
                return deferred.promise;
            },
            $remove: function() {
                console.group("$remove");
                var deferred, wakOptions = {}, that = this;
                deferred = $q.defer();
                wakOptions.onSuccess = function(event) {
                    rootScopeSafeApply(function() {
                        console.log("remove.onSuccess", "event", event);
                        deferred.resolve(event);
                    });
                };
                wakOptions.onError = function(error) {
                    rootScopeSafeApply(function() {
                        console.error("remove.onError", "error", error);
                        deferred.reject(error);
                    });
                };
                this.$_entity.remove(wakOptions);
                console.groupEnd();
                return deferred.promise;
            },
            $syncPojoToEntity: function() {
                console.group("$syncPojoToEntity");
                var pojo = this, key, infos, info;
                if (pojo.$_entity && pojo.$_entity._private && pojo.$_entity._private.values) for (key in pojo.$_entity._private.values) if (pojo.$_entity[key].getValue() !== pojo[key] && pojo.$_entity[key] instanceof WAF.EntityAttributeSimple) pojo.$_entity[key].setValue(pojo[key]);
                console.groupEnd();
            },
            $syncEntityToPojo: function() {
                var pojo = this, key;
                if (pojo.$_entity && pojo.$_entity._private && pojo.$_entity._private.values) for (key in pojo.$_entity._private.values) if (pojo.$_entity[key].getValue() !== pojo[key] && pojo.$_entity[key] instanceof WAF.EntityAttributeSimple) pojo[key] = pojo.$_entity[key].getValue();
                pojo.__KEY = pojo.$_entity.getKey();
                pojo.__STAMP = pojo.$_entity.getStamp();
            },
            $fetch: function() {
                var deferred, that = this, result, wakOptions = {};
                deferred = $q.defer();
                if (this.$_entity) {
                    wakOptions.onSuccess = function(event) {
                        rootScopeSafeApply(function() {
                            result = that.$_entity.getDataClass().$create(event.entity);
                            for (var key in result) if (result.hasOwnProperty(key)) that[key] = result[key];
                            deferred.resolve(result);
                        });
                    };
                    wakOptions.onError = function(error) {
                        rootScopeSafeApply(function() {
                            console.error("$fetch > Error while serverRefresh", error);
                            deferred.reject("$fetch > Error while serverRefresh" + error);
                        });
                    };
                    this.$_entity.serverRefresh(wakOptions);
                    return deferred.promise;
                } else if (this.$_deferred) $http({
                    method: "GET",
                    url: this.$_deferred.uri
                }).success(function(data, status, headers, config) {
                    result = that.$_deferred.dataClass.$create(data);
                    for (var key in result) if (result.hasOwnProperty(key)) that[key] = result[key];
                    delete that.$_deferred;
                    deferred.resolve(result);
                }).error(function(data, status, headers, config) {
                    console.error("$fetch > Error while fetching deferred entity", data, "status", status);
                    deferred.reject("$fetch > Error while fetching deferred entity" + data);
                }); else throw new Error("Couldn't fetch, an error occured, no $_entity or $_deferred");
                return deferred.promise;
            },
            $isLoaded: function() {
                if (this.$_entity) return true; else return false;
            },
            $toJSON: $$toJSON
        };
        var NgWakEntityAbstract = Class.extend(NgWakEntityAbstractPrototype);
        var NgWakEntityCache = function(options) {
            options = "undefined" === typeof options ? {} : options;
            this.maxEntities = options.maxEntities || DEFAULT_CACHE_SIZE;
            this.deep = options.deep || DEFAULT_CACHE_DEEP;
            this.infos = {};
            this.nbEntries = 0;
        };
        NgWakEntityCache.prototype.setSize = function(size) {
            if (null === size || size < DEFAULT_CACHE_SIZE) size = DEFAULT_CACHE_SIZE;
            this.maxEntities = size;
        };
        NgWakEntityCache.prototype.setDeep = function(deep) {
            this.deep = deep;
        };
        NgWakEntityCache.prototype.getCacheInfo = function(key) {
            return this.infos[key] || null;
        };
        NgWakEntityCache.prototype.replaceCachedEntity = function(key, entity) {
            var cachedEntity = this.getCacheInfo(key);
            if (null !== cachedEntity && entity.__STAMP > cachedEntity.__STAMP) cachedEntity = entity;
        };
        var directoryLoginByPassword = function(login, password) {
            var deferred, wakOptions = {};
            deferred = $q.defer();
            wakOptions.onSuccess = function(event) {
                deferred.resolve({
                    result: event.result
                });
            };
            wakOptions.onError = function(event) {
                deferred.reject(event);
            };
            WAF.directory.loginByPassword(login, password, wakOptions);
            return deferred.promise;
        };
        var directoryCurrentUser = function() {
            var deferred, wakOptions = {};
            deferred = $q.defer();
            wakOptions.onSuccess = function(event) {
                deferred.resolve({
                    result: event.result
                });
            };
            wakOptions.onError = function(event) {
                deferred.reject(event);
            };
            WAF.directory.currentUser(wakOptions);
            return deferred.promise;
        };
        var directoryLogout = function() {
            var deferred, wakOptions = {};
            deferred = $q.defer();
            wakOptions.onSuccess = function(event) {
                deferred.resolve({
                    result: event.result
                });
            };
            wakOptions.onError = function(event) {
                console.error(">logout", event);
                deferred.reject(event);
            };
            WAF.directory.logout(wakOptions);
            return deferred.promise;
        };
        var directoryCurrentUserBelongsTo = function(groupName) {
            var deferred, wakOptions = {};
            deferred = $q.defer();
            wakOptions.onSuccess = function(event) {
                deferred.resolve({
                    result: event.result
                });
            };
            wakOptions.onError = function(event) {
                deferred.reject(event);
            };
            WAF.directory.currentUserBelongsTo(groupName, wakOptions);
            return deferred.promise;
        };
        var $wakandaResult = {
            init: init,
            getDatastore: getDatastore,
            $login: directoryLoginByPassword,
            $loginByPassword: directoryLoginByPassword,
            $currentUser: directoryCurrentUser,
            $logout: directoryLogout,
            $currentUserBelongsTo: directoryCurrentUserBelongsTo
        };
        Object.defineProperty($wakandaResult, "$ds", {
            get: getDatastore
        });
        return $wakandaResult;
    } ]);
})({}, function() {
    return this;
}());
//# sourceMappingURL=angular-wakanda.debug.min.js.map